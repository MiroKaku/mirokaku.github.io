{"meta":{"title":"喵石榴","subtitle":"","description":"“梦想总是与你的价值观相联系。你相信什么，就会遇见什么。”","author":"MiroKaku","url":"https://mirokaku.github.io","root":"/"},"pages":[{"title":"","date":"2025-03-11T05:38:47.192Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"404.html","permalink":"https://mirokaku.github.io/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-03-11T05:38:47.231Z","updated":"2025-03-11T05:38:30.000Z","comments":false,"path":"about/index.html","permalink":"https://mirokaku.github.io/about/","excerpt":"","text":"本站由Hexo博客引擎以及Volantis(v5.5.0版本)主题框架搭建，不定期更新中~"},{"title":"所有分类","date":"2025-03-11T05:38:47.234Z","updated":"2025-03-11T05:38:30.000Z","comments":false,"path":"categories/index.html","permalink":"https://mirokaku.github.io/categories/","excerpt":"","text":""},{"title":"","date":"2025-03-11T05:38:47.237Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"comments/index.html","permalink":"https://mirokaku.github.io/comments/","excerpt":"","text":"请遵守相关法律法规，文明灌水，谢谢合作~"},{"title":"所有标签","date":"2025-03-11T05:38:47.283Z","updated":"2025-03-11T05:38:30.000Z","comments":false,"path":"tags/index.html","permalink":"https://mirokaku.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"现代 INF 模板","slug":"Modern-INF-Template","date":"2019-05-28T19:34:46.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"Modern-INF-Template/","permalink":"https://mirokaku.github.io/Modern-INF-Template/","excerpt":"前几天写了篇《传统 INF 模板》，今天来补充一下 KMDF 和 NDIS6 的 INF 模板. 这两个模板的编写方式和之前 Legacy 的模板不一样，是微软当前推荐使用的编写方法。","text":"前几天写了篇《传统 INF 模板》，今天来补充一下 KMDF 和 NDIS6 的 INF 模板. 这两个模板的编写方式和之前 Legacy 的模板不一样，是微软当前推荐使用的编写方法。 安装和卸载驱动现代的 INF 不能直接再使用 InstallHinfSection 来安装和卸载. 我给 devcon 添加了一些代码, 来支持 Legacy 和 NDIS6 的安装. 安装123456789; KMDF（devcon 原版）devcon.exe install KMDF.inf Root\\KMDF | | | |安装工具 安装命令 驱动 inf 路径 驱动硬件id(inf有写); KMDF（devcon 修改版 https://github.com/MiroKaku/devcon）devcon.exe install KMDF KMDF.inf Root\\KMDF | | | | |安装工具 安装命令 安装模式 驱动 inf 路径 驱动硬件id(inf有写) 12345; NDIS6.x（原版）netcfg /l NDIS6.inf /c s /i Root\\NDIS6; NDIS6.x（devcon 修改版）devcon.exe install NDIS6 NDIS6.inf Root\\NDIS6 KMDF 驱动 INF 模板 NDIS6.X 驱动 INF 模板","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Kernel","slug":"kernel","permalink":"https://mirokaku.github.io/tags/kernel/"},{"name":"INF","slug":"inf","permalink":"https://mirokaku.github.io/tags/inf/"}]},{"title":"传统 INF 模板","slug":"Legacy-INF-Template","date":"2019-05-25T16:53:18.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"Legacy-INF-Template/","permalink":"https://mirokaku.github.io/Legacy-INF-Template/","excerpt":"基本上，大家写完驱动都是通过一个加载器来加载驱动，我自己觉得太麻烦了...不如直接右键安装更方便. 下面是我自己使用的驱动 INF 文件模板，直接替换里面部分文件信息就可以直接使用。","text":"基本上，大家写完驱动都是通过一个加载器来加载驱动，我自己觉得太麻烦了...不如直接右键安装更方便. 下面是我自己使用的驱动 INF 文件模板，直接替换里面部分文件信息就可以直接使用。 INF 安装和卸载驱动安装驱动 可以直接右键 INF 文件，选择 &quot;安装&quot; 通过命令安装 1RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 128 C:\\WINDOWS\\INF\\SHELL.INF 卸载驱动1RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultUninstall 128 C:\\WINDOWS\\INF\\SHELL.INF NT 驱动 INF 模板有几个地方需要自行替换内容 1. `Version` 里面的 `Class`，`ClassGuid`，`DriverVer` 2. `SourceDisksFiles` 里面的文件名 3. `Strings` 里面的所有信息，根据自己的需求来填写 MiniFilter 驱动 INF 模板MiniFilter 的 INF 和 NT 基本差不多，只是多了个 MiniFilter 的 Instance 注册表的补充.","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Kernel","slug":"kernel","permalink":"https://mirokaku.github.io/tags/kernel/"},{"name":"INF","slug":"inf","permalink":"https://mirokaku.github.io/tags/inf/"}]},{"title":"关于 ProcessHollowing","slug":"About-ProcessHollowing","date":"2019-05-25T16:04:41.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"About-ProcessHollowing/","permalink":"https://mirokaku.github.io/About-ProcessHollowing/","excerpt":"ProcessHollowing (进程镂空) 也是出来很久了, 网上已经一大堆相关介绍的文章.我就不再详细介绍, 详细介绍请看&quot;傀儡进程的实现与检测&quot;, 这里就额外补充个小技巧.","text":"ProcessHollowing (进程镂空) 也是出来很久了, 网上已经一大堆相关介绍的文章.我就不再详细介绍, 详细介绍请看&quot;傀儡进程的实现与检测&quot;, 这里就额外补充个小技巧. 问题一假设我创建了一个 svchost 进程作为傀儡进程, 有一个问题就是: svchost 父进程不是 services.exe, 那么就能肉眼可见的发现这是个有问题的进程. 那么, 要怎么做才能做的更像 &quot;svchost&quot; 呢? 给 svchost 指定父进程为 services.exe 就行了.下面是关键代码, 这个技巧还是我之前逆向 CreateProcessInternalW 的时候发现的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344if (!InitializeProcThreadAttributeList( AttributeList, 2, 0, &amp;AttributeListSize))&#123; DosError = GetLastError(); break;&#125;// MSDN: https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattributeif (!UpdateProcThreadAttribute( AttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, // 指定父进程 &amp;ParentHandle, sizeof(ParentHandle), nullptr, nullptr))&#123; DosError = GetLastError(); break;&#125;auto Startup = STARTUPINFOEXW();Startup.StartupInfo.cb = sizeof(Startup);Startup.lpAttributeList = AttributeList;// ...DosError = CreateProcessHollowed( NewToken, nullptr, LR&quot;(C:\\Windows\\System32\\notepad.exe)&quot;, RealApp, Args, nullptr, nullptr, FALSE, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, // 这里有个 EXTENDED_STARTUPINFO_PRESENT nullptr, Sysdir, (LPSTARTUPINFOW)&amp; Startup, &amp;ProcessInfo);if (NOERROR != DosError)&#123; break;&#125; 问题二怎么用 32 位进程创建 64 位的镂空进程? 可以借助 wow64ext 这个库, 它可以让 Wow64 进程调用 64 位 Ntdll.dll 的系统调用.把 ProcessHollowing 里面对目标进程操作相关的 API 都换成 wow64ext 扩展的 API 就可以了. 例子代码MiroKaku&#x2F;ProcessHollowing","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Hack","slug":"hack","permalink":"https://mirokaku.github.io/tags/hack/"}]},{"title":"关于 InstrumentationCallback","slug":"About-InstrumentationCallback","date":"2019-05-24T21:22:14.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"About-InstrumentationCallback/","permalink":"https://mirokaku.github.io/About-InstrumentationCallback/","excerpt":"分析环境为 x64 版本 InstrumentationCallback 回调的技术刚出来的时候就收藏了, 一直没有去研究学习它. 现在有时间来看一下这个东西. 这个回调存储在 KPROCESS-&gt; InstrumentationCallback. 120: kd&gt; dtx nt!_KPROCESS [+0x100] InstrumentationCallback : 0x7FF6FA0E11AE","text":"分析环境为 x64 版本 InstrumentationCallback 回调的技术刚出来的时候就收藏了, 一直没有去研究学习它. 现在有时间来看一下这个东西. 这个回调存储在 KPROCESS-&gt; InstrumentationCallback. 120: kd&gt; dtx nt!_KPROCESS [+0x100] InstrumentationCallback : 0x7FF6FA0E11AE 它很有意思, 当从内核返回到用户层的时候, 就会触发这个回调.下面是一些触发点: LdrInitializeThunk KiUserExceptionDispatcher KiRaiseUserExceptionDispatcher KiUserCallbackDispatcher KiUserApcDispatcher sysret (KeSystemServiceExit) 怎么用 ?安装回调既然这个回调存储在 KPROCESS, 那么我们就看一下设置进程相关的 NtSetInformationProcess() 根据资料和分析可以知道传入参数的结构为: 123456789101112typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION&#123; PVOID Callback;&#125; PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, * PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;// Since Windows 10typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_EX&#123; ULONG Version; ULONG Reserved; PVOID Callback;&#125; PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_EX, * PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_EX; 下面代码是我对参数处理相关代码的还原: 123456789101112131415161718192021NtSetInformationProcess()&#123; // ... if ((aProcessInformationLength - 8) &amp; 0xFFFFFFF7) return STATUS_INFO_LENGTH_MISMATCH; if (aProcessInformationLength == 8) InstrumentationCallbackInfo.Callback = *(PVOID *)aProcessInformation; else InstrumentationCallbackInfo.Callback = *(PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION_EX *)aProcessInformation; if (InstrumentationCallbackInfo.Reserved) return STATUS_INVALID_PARAMETER; if (InstrumentationCallbackInfo.Version != InstrumentationCallbackInfo.Reserved) return STATUS_UNKNOWN_REVISION; if (InstrumentationCallbackInfo.Callback != (void *)((_QWORD)InstrumentationCallbackInfo.Callback &lt;&lt; 16 &gt;&gt; 16)) return STATUS_INVALID_PARAMETER; // ...&#125; 从代码中我们看到几个信息: 1. 函数接受两种长度的参数. 8 和 16 2. Reserved 必须为 0 3. Reversed 必须等于 Version 4. 回调地址必须是用户层回调地址 经过调试发现, Windows 10 之前的系统只支持长度为 8 的参数. 那么 NtSetInformationProcess() 的调用方法就是: 12345NtSetInformationProcess( GetCurrentProcess(), PROCESSINFOCLASS::ProcessInstrumentationCallback, // 40 Information, // PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION[EX] InformationLength); // 8 or 16 接下来我们就要看下怎么构造这个回调, 也就是要看下这个回调能用的参数是什么? 构造回调要想知道回调的参数是什么, 我们就要去看一下触发点. 我选了比较简单的 KiDispatchException() 函数来分析. 123456789101112131415KiDispatchException()&#123; // ... _disable(); TrapFrame-&gt;SegCs = 0x33; TrapFrame-&gt;Rip = KeUserExceptionDispatcher; InstrumentationCallback = KeGetCurrentThread()-&gt;ApcState.Process-&gt;InstrumentationCallback; if (InstrumentationCallback) &#123; v6-&gt;R10 = (unsigned __int64)TrapFrame-&gt;Rip; // return address v6-&gt;Rip = (unsigned __int64)InstrumentationCallback; &#125; _enable(); // ...&#125; 从代码中我们看到, KiDispatchException() 回到应用层是构造了一个 TrapFrame.其中有处关键的地方: R10, 如果存在 InstrumentationCallback 回调, 这个寄存器就用来存储本应该返回的地址. 其它就是正常展开 TrapFrame. 所以我们要自己构造一个垫片函数, 来正确处理参数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344include ksamd64.incEXTERN InstrumentationCallback:NEAR.CODEInstrumentationCallbackShim PROC ; https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention push rax push rcx push RBX push RBP push RDI push RSI push RSP push R12 push R13 push R14 push R15 ; homespace (rcx, rdx, r8, r9) sub rsp, 20h mov rdx, rax ; return value mov rcx, r10 ; return address call InstrumentationCallback add rsp, 20h pop R15 pop R14 pop R13 pop R12 pop RSP pop RSI pop RDI pop RBP pop RBX pop rcx pop rax jmp R10InstrumentationCallbackShim ENDP END 其他问题根据资料和调试分析得知几个注意的问题: Windows 10 之前的系统必须提升 Debug 特权, 才能正常调用 NtSetInformationProcess() Windows 10 之前的系统只支持传入 PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION 例子代码MiroKaku&#x2F;InstrumentationCallback 引用参考Hooking via InstrumentationCallbackWindows x64 system service hooks and advanced debugging","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Kernel","slug":"kernel","permalink":"https://mirokaku.github.io/tags/kernel/"}]},{"title":"配置 Windows 网络模式内核调试","slug":"Windbg-Network","date":"2018-10-03T19:07:33.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"Windbg-Network/","permalink":"https://mirokaku.github.io/Windbg-Network/","excerpt":"","text":"Windbg 版本要与被调试的 Windows 版本一致! 否则可能出现网络包不支持。 配置 配置虚拟机 123456bcdedit /copy &#123;current&#125; /d TestModebcdedit /set &#123;new&#125; debug on # 开启调试模式bcdedit /set &#123;new&#125; testsigning on # 开启测试签名模式bcdedit /set nointegritychecks on # 关闭驱动程序签名强制验证# hostip, port, key 自行修改bcdedit /dbgsettings net hostip:192.168.0.1 port:54231 key:xxxxx 打开 Windbg-&gt;File-&gt;Kernel Debugging，填入上面配置的 port 和 key 引用参考Setting Up KDNET Network Kernel Debugging Manually BCDEdit &#x2F;set BCDEdit &#x2F;dbgsettings","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Kernel","slug":"kernel","permalink":"https://mirokaku.github.io/tags/kernel/"},{"name":"Windbg","slug":"windbg","permalink":"https://mirokaku.github.io/tags/windbg/"},{"name":"Debug","slug":"debug","permalink":"https://mirokaku.github.io/tags/debug/"}]},{"title":"PDU 编码规则","slug":"PDU-Encode","date":"2017-05-18T11:36:02.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"PDU-Encode/","permalink":"https://mirokaku.github.io/PDU-Encode/","excerpt":"PDU模式不仅支持中文短信，也能发送英文短信。PDU模式收发短信可以使用3种编码：7-bit、8-bit和UCS2编码。7-bit编码用于发送普通的ASCII字符，8-bit编码通常用于发送数据消息，UCS2编码用于发送Unicode字符。","text":"PDU模式不仅支持中文短信，也能发送英文短信。PDU模式收发短信可以使用3种编码：7-bit、8-bit和UCS2编码。7-bit编码用于发送普通的ASCII字符，8-bit编码通常用于发送数据消息，UCS2编码用于发送Unicode字符。 PDU 内容总长度 140 个字节 (1120位)，支持采用三种编码方式：7-bit、8-bit 和 UCS2 编码。7-bit 编码——用于发送普通的 ASCII 字符，ASCII码表最大到0x7X，最高位为0，总 7-bit，实际编码时则可把8-bit的最高位比特使用起来，所以可支持1120&#x2F;7&#x3D;160个字符；8-bit 编码——用于发送数据消息，比如图片和铃声、二进制数据等，此类数据无法使用 7-bit 编码，因为那样会丢掉一位，也不能用下面UCS2编码，因为不符合 UNICODE 编码检查（范围）。8-bit 编码最多支持 140 个字节数据。UCS2 编码——用于发送 Unicode 字符，每个中文（韩文、日文），占用 2 字节，只要短信里包含这些多字节编码文字，那么即使还有英文，英文也需要安装 UCS2 编码，也占用 2 字节，所以，最多支持 70 个中文字（或中英混合短信） 编码格式一般的PDU编码由A B C D E F G H I J K L M十三项组成: SCA (短信中心) 结构部分：AT指令中 AT+CMGS&#x3D; Len不包含此段位组的长度 Index Item Description A &lt;sc_len&gt; B+C的长度, 1Byte B &lt;type_addr&gt; SMSC地址类型, 1Byte C &lt;number&gt; SMSC 号码 TPUD 结构部分： Index Item Description D &lt;option&gt; 基本参数(TP-MTI&#x2F;VFP), 1Byte E &lt;MR&gt; 短信标识符(TP-MR), 1Byte F v 目标号码长度, 1Byte G &lt;DA&gt; 被叫号码类型, 1Byte H ^ 被叫号码, 长度由F中的数据决定 I &lt;PID&gt; 协议标识(TP-PID), 1Byte J &lt;DCS&gt; 数据编码(TP-DCS), 1Byte K &lt;VP&gt; 有效期(TP-VP), 1Byte L &lt;UDL&gt; 用户数据长度(TP-UDL), 1Byte M &lt;UD&gt; 用户数据 SCA 结构部分详细说明&lt;sc_len&gt;：表示 （短信中心号码）的长度，包含两个字符，指示 和 所占字符的个数除于 2。 &lt;type_addr&gt;：表示号码地址类型，包含两个字符，其结构如下： 123bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit01 Type-of-number Numbering-plan-identification1 0 0 1 0 0 0 1 bit7 固定为 1 Type-of-number (bit6-bit4) 取值如下： value Descation 000 若用户不能识别目标地址号码时，选用此值。此时地址号码由网络侧决定。 001 若用户能识别是国际号码或者或者认为是国内范围时，选用此值。 010 国内号码，不允许加前缀或者后缀。在用户发送国内电话时，选用此值。 011 本网络内的特定号码，用于管理或者服务，用户不能选用此值。 101 号码类型为 GSM 的缺省 7-bit 编码方式。 110 短小号码，暂不使用。 111 扩展保留，暂不使用。 Numbering-plan-identification (bit3-bit0) 取值如下：(注：当 bit6-bit4 取值为 000, 001, 010 时才有效，其他情况 bit3-bit0 无效) value Descation 0000 号码由网络侧的号码方案确定 0001 ISDN&#x2F;电话号码方案 0011 数据号码方案，暂不使用 0100 Telex 号码方案，暂不使用 1000 国内号码方案，暂不使用 1001 私人号码方案，暂不使用 1010 ERMES 号码方案，暂不使用 &lt;numbers&gt;：表示地址号码，一个字节储存两个数字，且 bit3 ~ bit0 储存第一个数字，bit7 ~ bit4 储存第二个数字，如果号码为奇数，则最后一位补F后，再进行反转。如果为偶数，则不需要补F。像是反序的 8421 BCD 码，可如下例所示： 例如有13 81 23 45 67 8存储为21 18 32 54 76 F8 TPDU 结构部分&lt;option&gt;： 12RP UDHI SRR VPF RD MTIbit7 bit6 bit5 bit4-3 bit2 bit1-0 &lt;MTI&gt;：表示短消息类型。 bit1 bit0 Descrption 0 0 SMS-DELIVER (SC 到 MT 方向) 0 0 SMS-DELIVER-REPORT (MT 到 SC 方向) 1 0 SMS-STATUS-REPORT (SC 到 MT 方向) 1 0 SMS-COMMAND (MT 到 SC 方向) 0 1 SMS-SUBMIT (MT 到 SC 方向) 0 1 SMS-SUBMIT-REPROT (SC 到 MT 方向) 1 1 保留 &lt;RD&gt;：指示 SC 是否需要接受一个仍保存在 SC 中，与以前同一 OA 发出具有相同的 MR 和 DA 的短消息。 0 接受1 不接受 &lt;VPF&gt;：指示 VP 字段格式的有效性，格式指示。 bit1 bit0 Descrption 0 0 VP 字段无效 1 0 VP 字段有效，格式为 &quot;relative&quot; 0 1 VP 字段有效，格式为 &quot;enhanced&quot; 1 1 VP 字段有效，格式为 &quot;absolute&quot; &lt;RP&gt;：回复短信路径的设置指示，与短信发送时的设置相同。 0 没有设置1 设置，指示回复短信与发送时具有相同的 SC 号码设置，返回路径相同。 UDHI：用户数据头的指示。 0 用户数据段只有短消息的内容1 用户数据段除了短消息外，还包含有一个数据头 &lt;SRR&gt;：状态报告请求指示。 0 不需要一个短信成功发送的状态报告信息1 需要一个短信成功发送的状态报告信息 &lt;MR&gt;：表示短信标识符，取值范围为 0～255。 &lt;DA&gt;：目标地址信息，结构同 SCA，但是有一点不同需要注意！就是 len 字段不再是 type 和 number 的字节长度，而是 number 的字符长度 &lt;PID&gt;：协议指示。 Bit7-6 : Bit7 Bit6 (目前， Bit 7&#x3D;0 和 Bit 6&#x3D;0) 0 0 分配 bits 0-5 1 0 分配 bits 0-5 0 1 保留 1 1 分配 bits 0-5，为 SC 的特殊用途 Bit5 : 0 无交互操作，但有 SME-to-CSME 协议1 Telematic 交互操作 （此情况下， bit 4-0 的取值有效） Bit4-0 : 若取值为 10010，则表示 Email ，其它取值暂不支持。 &lt;DSC&gt;：表示用户数据的编码方式。 00 7-bit 编码 (英文)04 8-bit 编码 (图片和铃声)08 16-bit 编码 (UCS2) Bit No.7与Bit No.6：一般设置为00 Bit No.5：0-文本未压缩1-文本用GSM标准压缩算法压缩 Bit No.4：0-指示Bit No.1 Bit No.0为保留位，不含信息类型信息1-指示Bit No.1 Bit No.0含信息类型信息 Bit No.3与Bit No.2：00-默认的字符集，每字符占7bit，此时最大可发送160字符01-8bit，此时最大可发送140字符10-USC2（16bit），发送双字节字符集11-预留 Bit N0.1与Bit No.0：00-Class 0，短消息直接显示在屏幕上01-Class 1，10-Class 2（SIM卡特定信息），11-Class 3 &lt;VP&gt;：表示有效期，时间从短消息被 SC 接收到开始计算。如果 &#x3D;00，则该字段缺失，时间表示如下： VP 取值 说明 0~143 (VP + 1) x 5 minutes 144~167 12 hours + ((VP - 143) x 30 minutes) 168~196 (VP - 166) x 1 day 197~255 (VP - 192) x 1 week &lt;UDL&gt;：表示用户数据长度，取值取决于具体的编码方式。 若是 7-bit 缺省编码， 表示共有多少个 septets。 若是 8-bit 编码， 表示共有多少个 Octets。 若是 UCS2 编码， 表示共有多少个 Octets。 若是有压缩的 7-bit 或 8-bit 或 UCS2 编码， 表示压缩后共有多少个 Octets。 对压缩的短信编码， 的数据长度不超过 160 septets；对无压缩编码的短信， 长度不超过 140 Octets。 &lt;UD&gt;：表示用户数据，其有效数据由参数 决定。 举个栗子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849AT+CMGW=300891683108705505F011000791680180F60008AA1200480065006C006C006F002055B555B5FF01AT 指令后面这个长度是 &lt;TPUD 结构的8位字节个数&gt;首先看下 SCA 结构 0891683108705505F00x08SCA 号码类型和号码的长度0x91SCA 号码为国际号码，即 &quot;+&quot;683108705505F0可解析短信中心号码为 8613800755500然后看下 TPUD 结构 11000791680180F60008AA1200480065006C006C006F002055B555B5FF010x11 optionsBit No. 7 6 5 4 3 2 1 0 RP UDHI SRR VPF VPF RD MTI MTI 0 0 0 1 0 0 0 10x00 MR置为00即可0791680180F6 DA解析为 07 91 86100860x00 PID对于标准情况下的MS-to-SC短消息传送，只需设置PID为000x08 DCSUSC2（16bit）双字节字符集0xAA 有效期第一种情况（相对的）：VPF=10 VP=AAH（四天），在这里是第一种第二种情况（绝对的）：VPF=11年 月 日 时 分 秒 时区30 80 02 90 54 33 20 表示：03-08-20 09:45:330x12 UDL18 个8位字节0048 0065 006C 006C 006F 0020 55B5 55B5 FF01H e l l o 空格 喵 喵 ！","categories":[{"name":"other","slug":"other","permalink":"https://mirokaku.github.io/categories/other/"}],"tags":[]},{"title":"IDA + VMWare 调试系统","slug":"IDA-VM-System","date":"2017-05-12T19:00:18.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"IDA-VM-System/","permalink":"https://mirokaku.github.io/IDA-VM-System/","excerpt":"","text":"配置虚拟机打开虚拟机目录下的 vmx 文件, 添加设置项 32 位客户机系统1234567debugStub.port.guest32 = &quot;54232&quot; ; x86 默认调试端口 8832debugStub.listen.guest32 = &quot;TRUE&quot;debugStub.listen.guest32.remote = &quot;TRUE&quot; debugStub.hideBreakpoints = &quot;TRUE&quot; ; 启用使用硬件断点而不是软件 (INT3) 断点monitor.debugOnStartGuest32 = &quot;TRUE&quot; ; 在第一条指令 (在BIOS! 中警告) 中断进入DebugStub ; 这将在第一条指令在0xFFFF0处停止VM, 您可以设置下一个断点来破坏* 0x7c00引导加载程序由BIOS加载bios.bootDelay = &quot;3000&quot; ; 延迟启动BIOS代码 64 位客户机系统123456debugStub.port.guest64 = &quot;54264&quot; ; x64 默认调试端口 8864debugStub.listen.guest64 = &quot;TRUE&quot;debugStub.listen.guest64.remote = &quot;TRUE&quot;debugStub.hideBreakpoints = &quot;TRUE&quot;monitor.debugOnStartGuest64 = &quot;TRUE&quot;bios.bootDelay = &quot;3000&quot; 配置调试器IDA -&gt; Debugger -&gt; Attach -&gt; Remote GDB debugger hostname 填写 localhost，port 填上面给出的[默认]端口 设置内存布局Alt + S 设置内存布局 32 Bit: 0x0 ~ 0xFFFFFFF064 Bit: 0x0 ~ 0xFFFFFFFFFFFFFFF0 如果是要调试 BIOS 代码, 那么应创建一个从 0xF0000 到 0x10000 的 16 位段","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Kernel","slug":"kernel","permalink":"https://mirokaku.github.io/tags/kernel/"},{"name":"Windbg","slug":"windbg","permalink":"https://mirokaku.github.io/tags/windbg/"},{"name":"Debug","slug":"debug","permalink":"https://mirokaku.github.io/tags/debug/"}]},{"title":"Objective-C 学习笔记","slug":"OC-Notes","date":"2016-09-03T13:20:00.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"OC-Notes/","permalink":"https://mirokaku.github.io/OC-Notes/","excerpt":"之前学习 Objective-C 时整理的笔记，文章内错误之处还望指点...","text":"之前学习 Objective-C 时整理的笔记，文章内错误之处还望指点... Hello World123456789#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char *argv[])&#123; @autoreleasepool &#123; // insert code here... NSLog(@&quot;Hello, World&quot;); &#125; return 0;&#125; #import 就相当于 C++ 里面的 #include 123@autoreleasepool &#123; ...&#125; &#123;...&#125; 之间的语句会在被称之为 “自动释放池” 的语境中执行。 自动释放池的机制是：它使得应用在创建新对象时，系统能够有效的管理应用所使用的内容。 @&quot;Hello, World&quot; 此处的 @ 符号在位于一对双引号的字符串前面，这称为常量 NSString 对象。如果前面没有 @ 字符，就是在编写常量 C 类型的字符串。有了这个符号就是在编写 NSString 字符串对象。 同 C 语言一样，Objective-C 的所有程序语句必须使用分号（;）结束。 这篇文章主要是讲 Objective-C 与 C++ 的区别... 类、对象和方法消息传递Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格&#x2F;在源码风格方面，这是它与C Family语言（包括C&#x2F;C++、Java、世界上最好的语言PHP）差别最大的地方。 在Java、C++世界，我们调用一个对象的某个方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同。 在Java、C++里，对象和方法关系非常严格，一个方法必须属于一个类对象，否则编译要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态确定，给类型发送一个它无法处理的消息，也只会抛出一个异常而不会挂掉。 Language Call Method Objective-C [obj undefineMethod]; C++ obj.undefineMethod(); 在代码里调用没定义的方法（这是Java、C++世界习惯的说法，专业叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但能编译成功，运行的时候会出错。它会输出这样一个错误： 12016-06-24 10:48:46.851 Learn[16979:412230] *** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;-[obj undefineMethod]: unrecognized selector sent to instance 0x100111b90&#x27; 函数调用前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例： 不带参数 1StartedBlock(); 带参数 12NSLog(@&quot;decrypted string: %@&quot;, str);CGRectMake(0, 0, 0, 0); 传递消息给类 &#x2F; 实例方法 不带参数 Language Method Objective-C [obj method]; C++ obj.method(); 带一个参数 Language Method Objective-C [counter increase:1]; C++ counter.increase(1); 带多个参数对于C Family 程序员来说，这是最难接收，最反人类的 Language Method Objective-C -(void) setColorToRed: (float)red Green: (float)green Blue: (float)blue {…} &#x2F;&#x2F; 定义方法 | [myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; // 传递消息 C++ | public void setColorToRedGreenBlue(float red, float green, float blue) {…} | myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2); 消息嵌套 Language Method Objective-C UINavigationBar *bar &#x3D; [ [ [UINavigationBar alloc] init] autorelease]; C++ UINavigationBar bar &#x3D; UINavigationBar.alloc().inti().autorelease(); 类的定义与实现Objective-C中强烈要求将类的定义（interface）与实现（implementation）分为两个部分。类的定义文件遵循C语言之习惯，头文件以.h为后缀，实现文件以.m为后缀（也有.mm的扩展名，表示Objective-C与C++混合编程） 举个栗子： Interface定义部分，清楚定义了类的名称、数据成员和方法。以关键字@interface作为开始，@end作为结束。 1234567891011@interface MyObject : NSObject &#123; int memberVar1; //实体变量 id memberVar2;&#125;+(return_type) class_method; // 类方法-(return_type) instance_method1; // 实例方法-(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 方法前面的+&#x2F;-号代表函数的类型：加号（+）代表类方法（class method），不需要实例就可以调用，与C++的静态函数（static member function）相似。减号（-）即是一般的实例方法（instance method）。 下面是意义相近的 C++ 语法对照： 123456789101112class MyObject : public NSObject &#123; protected: int memberVar1; // 实体变量 void *memberVar2; public: static return_type class_method(); // 类方法 return_type instance_method1(); // 实例方法 return_type instance_method2(int p1); return_type instance_method3(int p1, int p2);&#125; Objective-C 定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C 方法使得参数可以夹于名称中间，不必全部依附于方法名称的尾端，可以提高程序可读性。设定颜色RGB值得方法为例子： 123- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; // 宣告方法[myColor setColorToRed:1.0 Green:0.8 Blue:0.2]; // 呼叫方法 这个方法的签名是setColorToRed:Green:Blue:。每个冒号后面都带着一个float类别的参数，分别代表红，绿，蓝三色。 Implementation实现区块则包含了公开方法的实现，以及定义私有变量及方法。以关键字@implementation作为区块起头，@end结尾。 1234567891011121314151617181920@Implementation MyObject &#123; int memberVar3; // 私有实体变量&#125;+(return_type) class_method &#123; ... // method Implementation&#125;-(return_type) instance_method1 &#123; ...&#125;-(return_type) instance_method2: (int) p1 &#123; ...&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ...&#125;@end 值得一提的是不只Interface区块可定义实体变量，Implementation区块也可以定义实体变量，两者的差别在于访问权限的不同。Interface区块内的实体变量默认权限为protected，宣告于implementation区块的实体变量则默认为private，故在Implementation区块定义私有成员更匹配面向对象之封装原则，因为如此类别之私有信息就不需曝露于公开interface（.h文件）中。 创建对象Objective-C创建对象需通过alloc以及init两个消息。alloc的作用是分配内存，init则是初始化对象。 init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。以下为范例： 1MyObject *my = [[MyObject alloc] init]; 在Objective-C 2.0里，若创建对象不需要参数，则可直接使用new 1MyObject *my = [MyObject new]; 仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写init方法，来添加额外的工作。（用途类似C++ 的构造函数constructor） 123456- (id) init &#123; if (self = [super init]) &#123; // 必须调用父类的 init // do something here ... &#125; return self;&#125; 数据类型和表达式OC 有4个基本数据类型：int, float, double, char。概念同C++一样5个限定词：long, long long, short, unsigned, signed。概念同 C++ 一样 下面来说几个特殊的类型： BOOL 类型概念同 C++ 一样，但是预定义的真假值与 C++ 不同： Language 真 假 Objective-C YES NO C++ true false id 类型id类型是 OC 里一个比较特殊的类型。概念上与 void* 类型很像，但是他们两个有很大区别。在内部处理上，这种类型被定义为 指向对象的指针，实际上是一个 指向这种对象的实例变量的指针 下面是 id 在 Objc.h 中的定义： 1234567/// Represents an instance of a class.struct objc_object &#123; class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 从上面看出，id是指向struct objc_object的一个指针。也就是说，id是指向任何一个继承了Object（或者NSObject）类的对象。需要注意的是，id是一个指针，所以在使用的时候不需要加星号（*）。 SEL 类型在 Objective-C 中，SEL 是选择器的一个类型。我们可以将 SEL 理解为函数指针，但他们之间并非完全一样。 nil 类型与 C++ 中 null 概念一样，是是对 nill 操作不会有任何作用，C++ 中对 null 操作会异常。 基础数据类型表： 类型 实例 NSLog 字符 char &#39;a&#39;、&#39;\\n&#39; %c short int - %hi、%hx、%ho unsigned short int - %hu、%hx、%ho int 12、-97、0xFFE0、0177 %i、%x、%o unsigned int 12u、100U、0XFFu %u、%x、%o long int 12L、-200l、0xffffL %li、%lx、%lo unsigned long int 12UL、100ul、0xffeeUL %lu、%lx、%lo long long int 0xe5e5e5e5LL、0xffeeUL %lli、%llx、%llo unsigned long long int 12ull、0xffeeULL %llu、%llx、%llo float 12.34f、3.1e-5f、0x1.5p10、0x1P-1 %f、%e、%g、%a double 12.34、3.1e-5、0x.1p3 %f、%e、%g、%a long double 12.34L、3.1e-5l %Lf、%Le、%Lg id nil %p 基本算术运算符概念同 C++ 一样 循环结构和选择结构同C++11一样，for循环有两种：普通for循环，快速for循环 123456789101112// 第一种遍历：普通 for 循环long int count = [array count];for (int i = 0; i &lt; count; ++i) &#123; NSLog(@&quot;1 遍历 array：%zi -&gt; %@&quot;, i, [array objectAtIndex:i]);&#125;// 第二种遍历：快速 for 循环int i = 0;for (id obj in array) &#123; NSLog(@&quot;2 遍历 array：%zi -&gt; %@&quot;, i, obj); ++i;&#125; 其他的 while，do…while，break，continue 都同 C++ 一致选择结构，if，if…else…，switch同 C++ 一致 类合成存取方法12345678910111213141516171819202122232425262728293031323334353637@interface Fraction : NSObject@property int numerator, denominator;- (void) print;- (double) convertToNum;@ end@Implementation Fraction@synthesize numerator, denominator;- (void) print &#123; NSLog(@&quot;%i / %i&quot;, numerator, denominator);&#125;- (double) convertToNum &#123; if (denominator != 0) &#123; return (double) numerator / denominator; &#125; else &#123; return NAN; &#125;&#125;@ endint main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *objFraction = [Fraction new]; [objFraction setNumerator:1]; [objFraction setDenominator:2]; [objFraction print]; &#125; return 0;&#125; 从OC 2.0开始，可自动生成设值方法和取值方法。第一步是在接口部分中使用@property指令标识属性。第二步是在实现部分中使用@synthesize 如果使用了@property指令，就不需要再实现部分声明相应的实例变量。 当然，你并不需要使用@synthesize指令，使用@property指令编译器也会自动为你生成setter和getter。但是要注意，如果你不使用@sythesize，那么编译器生成的实例变量会以下画线（_）字符作为其名称的第一个字符。 访问属性访问属性有两种格式：Instance.property = value; 等价为 [Instance setProperty: value]; 继承123456789101112131415161718192021222324@interface ClassA : NSObject &#123; int x;&#125;- (void) initVar;@end@implementation ClassA- (void) initVar &#123; x = 100;&#125;@end@interface ClassB : ClassA- (void) printVar;@end@implementation ClassB- (void) printVar &#123; NSLog(@&quot;x = %i&quot;, x);&#125;@end 在这段代码里面，ClassA继承于NSObject，ClassB继承于ClassA。语法同C++差不多。但是有一点要注意：OC只能是单继承，而C++可以多继承。 继承的概念作用于整个继承链。 @class 指令例如 @class XYPoint;在头文件声明中，告诉编译器XYPoint是一个类的名字。而不需要 #import 导入整个 XYPoint.h在C++中相当于 class XYPoint; 处理动态类型的方法： 方法 问题或行为 -(BOOL) isKindOfClass: class-object 对象是不是 class-object 或其子类的成员 -(BOOL) isMemberOfClass: class-object 对象是不是 class-object 的成员 -(BOOL) respondsToSelector: Selector 对象是否能够相应 selector 所指定的方法 -(BOOL) instancesRespondToSelector: Selector 指定的类实例是否能够响应 selector -(BOOL) isSubclassOfClass: class-object 对象是否是指定类的子类 -(id) performSelector: selector 应用 selector 指定的方法 -(id) performSelector: selector withObject: object 应用 selector 指定的方法，传递参数 object -(id) performSelector: selector withObject: object1 withObject: object2 应用 selector 指定的方法，传递参数 object1 和 object2 多态在OC里面的多态与C++有些不一样。在OC里面，不同类的相同方法名即为多态。而在C++里面就不一样咯。C++里面的多态是通过继承来实现的。 举个最简单的例子： Objective-C 1234567891011121314151617181920212223242526272829303132333435363738394041@interface ClassA : NSObject &#123; int x;&#125;- (void) intVar;- (void) printVar;@end@implementation ClassA- (void) initVar &#123; x = 100;&#125;- (void) printVar &#123; NSLog(@&quot;x = %i&quot;, x)&#125;@end@interface ClassB : ClassA- (void) initVar;@end@implementation ClassB- (void) initVar &#123; x = 200;&#125;@endint main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; ClassA *myClassA = [ClassB new]; [myClassA initVar]; [myClassA printVar]; &#125; return 0;&#125; C++ 1234567891011121314151617181920212223242526272829303132333435class ClassA&#123;protected: int x;public: void initVar() &#123; x = 100; &#125; void printVar() &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;&#125;;class ClassB : public ClassA&#123;public: void initVar() &#123; x = 200; &#125;&#125;int main(int argc, const char *argv[])&#123; ClassA *myClassA = new ClassB(); myClassA-&gt;initVar(); myClassA-&gt;printVar(); getchar(); return 0;&#125; C++ 输出的结果是100而OC输出的结果是200，OC是真的覆盖… 另外，OC不支持运算符重载… 异常处理@try、@catch、@throw、@finally这些概念同C一样。 分类和协议分类在Objective-C的设计中，一个主要的考虑即为大型代码框架的维护。结构化编程的经验显示，改进代码的一种主要方法即为将其分解为更小的片段。Objective-C借用并扩展了Smalltalk实现中的“分类”概念，用以帮助达到分解代码的目的。 分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法，而无需持有原有的代码，或是重新编译原有的类。在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。 若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。 举个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// Integer.h#import &lt;objc/Object.h&gt;@interface Integer : Object &#123;@private int integer;&#125;@property (assign, nonatomic) integer;@end// Integer.m#import &quot;Integer.h&quot;@implementation Integer@synthesize integer;@end// Arithmetic.h#import &quot;Integer.h&quot;@interface Integer(Arithmetic)- (id) add: (Integer *) addend;- (id) sub: (Integer *) subtrahend;@end// Arithmetic.m#import &quot;Arithmetic.h&quot;@implementation Integer(Arithmetic)- (id) add: (Integer *) addend &#123; self.integer = self.integer + addend.integer; return self;&#125;- (id) sub: (Integer *) subtrahend &#123; self.integer = self.integer - subtrahend.integer; return self;&#125;@end// Display.h#import &quot;Integer.h&quot;@interface Integer(Display)- (id) showstars;- (id) showint;@end// Display.m#import &quot;Display.h&quot;@implementation Integer(Display)- (id) showstars &#123; int i, x = self.integer; for (i = 0; i &lt; x; ++i) printf(&quot;*&quot;); printf(&quot;\\n&quot;); return self;&#125;- (id) showint &#123; printf(&quot;%d\\n&quot;, self.integer); return self;&#125;@end// main.m#import &quot;Integer.h&quot;#import &quot;Arithmetic.h&quot;#import &quot;Display.h&quot;int main (void) &#123; Integer *num1 = [Integer new], *num2 = [Integer new]; int x; printf(&quot;Enter an integer: &quot;); scanf(&quot;%d&quot;, &amp;x); num1.integer = x; [num1 showstars]; printf(&quot;Enter an integer: &quot;); scanf(&quot;%d&quot;, &amp;x); num2.integer = x; [num2 showstars]; [num1 add:num2]; [num1 showint]; return 0;&#125; 类的扩展有一种特殊的情况是创建一个未命名的分类，且在括号“（）”之间不指定名字。这种特殊的语法定义称为类的扩展。定义一个像这样命名的分类时，可以通过定义额外的实例变量和属性来扩展类，这在有命名的分类中是不允许的。未命名分类中声明的方法需要在主实现区域实现，而不是在分离的实现区域中实现。未命名的分类是非常有用的，因为他们的方法都是私有的。如果需要写一个类，而且数据和方法仅供这个类本身使用，未命名分类比较合适。 通过使用分类添加新方法来扩展类不仅会影响这个类，同时也会影响他的所有子类。 协议协议是一组没有实现的方法列表，任何的类均可采纳协议并具体实现这组方法。协议列出了一组方法，有些可以是选择实现，有些是必须实现。定义一个协议很简单：只要使用@protocol指令，后面跟上你给出的协议名称。然后和处理接口部分一样，声明一些方法。@end指令之前的所有方法声明都是协议的一部分。在@optional指令之后列出的所有方法都是可选的。 个人感觉类似于C++的虚基类… 举个栗子： 1234@protocol Printable@optional - (void) print:(NSString)str;@end 加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。 12@interface class MyClass : NSObject &lt;Printable, Drawable&gt;@end 一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。 可以使用conformsToProtocol:方法检查一个对象是否遵循某项协议。 12345id currentObject;...if ([currentObject conformsToProtocol: @protocol (Drawable)] == YES) &#123; ...&#125; 这里使用的专用@protocol指令用于获取一个协议名称，并产生一个protocol对象，conformsToProtocol: 方法期望这个对象作为它的参数。 为了测试一个对象是否实现了可选的print方法，可以编写下列代码： 123if ([currentObject respondsToSelector: @selector (print)] == YES) &#123; [currentObject print];&#125; 通过在类型名称之后的尖括号中添加协议名称，借助编译器来检查变量的一致性：id &lt;Drawable&gt; currentObject; 块概念上，匿名函数，lambda，closure（或OC中的blocks）是一个东西。详见：浅析匿名函数、lambda表达式、闭包（closure）区别与作用 块是以插入字符 ^ 开头为标识的。后面跟的一个括号表示块所需要的参数列表。同样，也可以将这个块赋给一个变量。举个栗子： 123456789...__block int foo = 10;void (^printFoo)(void) = ^(void) &#123; foo = 20; NSLog(@&quot;foo = %i&quot;, foo); &#125;;printFoo(); 如果要试图在块内部改变变量的值，需要在定义本地变量之前插入 __block 修改器。 数字、字符串和集合在Foundation框架包括大量的类、方法和函数。可以通过这条代码来导入：#import &lt;Foundation/Foundation.h&gt; 里面的东西就相当于C++的标准库似的。使用的时候看看文档就好了。 数字对象NSNumber类包含多个方法，可以使用初始值创建NSNumber对象。 NSNumber 的创建方法和检索方法： 创建和初始化方法 初始化实例方法 检索实例方法 numberWithChar; initWithChar; charValue numberWithUnsignedChar; initWithUnsignedChar; unsignedCharValue numberWithShort; initWithShort; shortValue numberWithUnsignedShort; initWithUnsignedShort; unsignedShortValue numberWithInteger; initWithInteger; integerValue numberWithUnsignedInteger; initWithUnsignedInteger; unsignedIntegerValue numberWithInt; initWithInt; intValue numberWithUnsignedInt; initWithUnsignedInt; unsignedIntValue numberWithLong; initWithLong; longValue numberWithUnsignedLong; initWithUnsignedLong; unsignedLongValue numberWithLongLong; initWithLongLong; longLongValue numberWithUnsignedLongLong; initWithUnsignedLongLong; unsignedLongLongValue numberWithFloat; initWithFloat; floatValue numberWithDouble; initWithDouble; doubleValue numberWithBool; initWithBool; boolValue OC是允许通过@表达式创建数字对象的。 举栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Foundation/Foundation.h&gt;int main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; NSNumber *myNumber, *floatNumber, *intNumber; NSInteger myInt; // integer 整值 intNumber = [NSNumber numberWithInteger: 100]; myInt = [intNumber integerValue]; NSLog(@&quot;%li&quot;, (long)myInt); // long 整值 myNumber = [NSNumber numberWithLong: 0xabcdef]; NSLog(@&quot;%lx&quot;, [myNumber longValue]); // char 整值 myNumber = [NSNumber numberWithChar: &#x27;X&#x27;]; NSLog(@&quot;%c&quot;, [myNumber charValue]); // float 整值 floatNumber = [NSNumber numberWithFloat: 100.00]; NSLog(@&quot;%g&quot;, [floatNumber floatValue]); // double myNumber = [NSNumber numberWithDouble: 12345e+15]; NSLog(@&quot;%lg&quot;, [myNumber doubleValue]); // 发生错误 NSLog(@&quot;%li&quot;, (long)[myNumber integerValue]); // 验证两个 Number 是否相等 if ([intNumber isEqualToNumber: floatNumber] == YES) NSLog(@&quot;Numbers are equal&quot;); &#125;&#125; 字符串对象@”Hello World!” 就是一个字符串对象。即NSString类的对象。特殊情况下，它属于NSConstantString类的常量字符串对象。NSConstantString类是字符串对象NSString类的子类 description 方法可以使用格式化字符%@显示数组、字典和集合的全部内容。事实上，通过覆盖集成的description方法，还可以使用这些格式字符显示你自己的类对象。如果不覆盖方法，NSLog仅仅显示类名和该对象在内存中的地址，这是从NSObject类继承的description方法的默认实现。 举个栗子： 1234567891011121314151617181920212223242526@interface Fraction : NSObject@ property int numberator, denominator;- (void) setNumerator: (int)numerator andDenominator: (int) denominator;- (NSString *) description;@end@implementation Fraction- (void) setNumerator: (int)numerator andDenominator: (int)denominator &#123; self.numerator = numerator; self.denominator = denominator;&#125;- (NSString *) description &#123; return [NSString stringWithFormat:@&quot;%i/%i&quot;, self.numerator, self.denominator];&#125;@endint main (int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *f = [Fraction new]; [f setNumerator:1 andDenominator:2]; NSLog(@&quot;%@&quot;, f); &#125; return 0;&#125; 结果：2016-06-28 16:26:08.873 Learn[18105:485920] 1/2 可变对象与不可变对象@”Hello World!”创建字符串对象时，会创建一个内容不可更改的对象，称为不可变对象，可以使用NSString类处理不可变字符串。若要需要经常处理字符串并更改字符串中的字符，可以使用NSMutableString类处理 数组对象可变数组：NSArray不可变数组：NSMutableArray 挺简单的…使用的时候看看文档就行了.. 这里就说一下排序：利用NSArray数组排序的方法很容易实现。这里以NSMutableArray为例子：在NSMutableArray类中sortUsingSelegtor: 的方法很容易实现。举个栗子: 1234567- (NSComparisonResult) compareNames: (id) element &#123; return [name compare: [element name]];&#125;- (void) sort &#123; [book sortUsingSelector: @selector (compareNames)];&#125; sortUsingSelector: 方法会使用selector比较两个元素。由于数组可以包含任何类型的对象，所以要实现一般的排序方法，唯一途径就是由你来判断数组中的元素是否有序，为此，你必须添加一个方法比较数组中的两个元素。 这个方法返回的结果是NSComparisonResult类型的值。如果希望排序方法将第一个元素放在第二个元素之前，那么方法的返回值应是NSOrderedAscending。如果认为这两个元素相等，那么返回NSOrderedSame。如果排序后的数组中，第一个元素应该在第二个元素之后，那么返回NSOrderedDescending。 也阔以使用块排序：SortUsingComparator: (NSComparator) block;NSComparator 作为typedef定义在系统头文件中：Typedef NSComparisonResult (^NSComparator) (id obje1, id obj2);NSComparator 是一个区块，使用两个对象作为参数，并返回NSComparisonResult类型的值。 123456- (void) sort &#123; [book SortUsingComparator: ^(id obj1, id obj2) &#123; return [[obj1 name] compare: [obj2 name]]; &#125;];&#125; NSValue 类像数组这样的Foundation集合只能存储对象，而有些类型是源于C语言的一种数据类型，比如结构，它不是对象。我们可以利用 NSValue 把结构包装（wrapping）成对象。逆向的处理是从对象中解出基本类型，简称展开（unwrapping）。 NSValue 包装和展开方法 Typedef 数据类型 描述 包装方法 展开方法 CGPoint x 和 y 值组成的点 valueWithPoint; pointValue CGSize 宽和高组成的尺寸 valueWithSize; sizeValue CGRect 矩形包含原点和尺寸 valueWithRect; rectValue NSRange 描述位置和大小的范围 valueWithRange; rangeValue 词典对象词典是由键-对象对儿组成的数据集合。概念和C++里面的std::map一样。词典中的键必须是单值的，通常他们是字符串，但也可以是其他对象类型，和键关联的值可以使任何对象类型，但不能是nil。 不可变字典：NSDictionary可变字典：NSMutableDictionary [NSMutableDictionary dictionary]; 创建一个空字典 其他也挺简单的，使用上也和map差不多。看看文档就好了~ 集合对象set是一组单值对象集合，它可以是可变的，也可以是不可变的。操作包括：搜索、添加、删除集合中的成员（仅可变集合），比较两个集合，计算两个集合的交集和并集等。 也是和C++里面的std::set差不多 Foundation框架同样提供了一个名为NSCountedSet的类，这种集合同一对象可以出现多次，然而并非在集合众存在多次这个对象，而是维护一个计数值。 使用文件管理文件和目录：NSFileManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; NSString *fName = @&quot;~/Documents/testfile&quot;; NSFileManager *fm; NSDictionary *attr; NSError *err; fName = [fName stringByExpandingTildeInPath]; // 需要创建文件管理器的实例 fm = [NSFileManager defaultManager]; // 首先确认文件存在 if ([fm fileExistsAtPath: fName] == NO) &#123; NSLog(@&quot;File doesn&#x27;t exist!&quot;); return 1; &#125; // 创建一个副本 // 这里要注意下比较坑，如果同名文件存在，是会copy失败的 // 而且返回的失败信息是 testfile 文件不存在.... if ([fm copyItemAtPath: fName toPath: @&quot;newfile&quot; error: &amp;err] == NO) &#123; NSLog(@&quot;File Copy failed!, %@&quot;, err); return 2; &#125; // 测试两个文件是否一致 if ([fm contentsEqualAtPath: fName andPath: @&quot;newfile&quot;] == NO) &#123; NSLog(@&quot;Files are not equal!&quot;) return 3; &#125; // 重命名副本 if ([fm moveItemAtPath:@&quot;newfile&quot; toPath:@&quot;newfile2&quot; error:&amp;err] == NO) &#123; NSLog(@&quot;File rename failed&quot;); return 4; &#125; // 获取 newfile2 的大小 if ((attr = [fm attributesOfItemAtPath:@&quot;newfile2&quot; error:&amp;err]) == nil) &#123; NSLog(@&quot;Couldn&#x27;t get file attributes!&quot;); return 5; &#125; NSLog(@&quot;File size is %llu bytes&quot;, [[attr objectForKey:NSFileSize] unsignedLongLongValue]); // 最后删除原始文件 if ([fm removeItemAtPath:fName error:&amp;err] == NO) &#123; NSLog(@&quot;file removal failed&quot;); return 6; &#125; NSLog(@&quot;All operations were successful&quot;); // 显示新创建的文件内容 NSLog(@&quot;%@&quot;, [NSString stringWithContentsOfFile:@&quot;newfile2&quot; encoding:NSUTF8StringEncoding error:&amp;err]); &#125; return 0;&#125; 使用 NSData 类使用文件时，需要频繁的将数据读入到一个缓冲区，Foundation的NSData类提供了一种简单的方式，它用来设置缓冲区，将文件的内容读入缓冲区，或将缓冲区的内容写到一个文件。据说，据说哈，32位应用的NSData缓冲区最多可存储2G的数据。64位的最多可存储8EB的数据… 举例子： 1234567891011121314151617181920212223242526272829303132333435int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @&quot;~/Documents/testfile&quot;; NSFileManager *fm; NSData *fileData; fName = [fName stringByExpandingTildeInPath]; // 需要创建文件管理器的实例 fm = [NSFileManager defaultManager]; // 首先确认文件存在 if ([fm fileExistsAtPath: fName] == NO) &#123; NSLog(@&quot;File doesn&#x27;t exist!&quot;); return 1; &#125; // 读取文件 fileData = [fm contentsAtPath:fName]; if (fileData == nil) &#123; NSLog(@&quot;File read failed!&quot;); return 2; &#125; // 将数据写入 newfile3 if ([fm createFileAtPath:@&quot;newfile3&quot; contents:fileData attributes:nil] == NO) &#123; NSLog(@&quot;couldn&#x27;t create the copy!&quot;); return 3; &#125; NSLog(@&quot;File copy was successful!&quot;); &#125; return 0;&#125; 枚举目录中的内容123456789101112131415161718192021222324252627282930int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @&quot;~/Documents/testfile&quot;; NSFileManager *fm; NSDirectoryEnumerator *dirEnum; NSArray *dirArray; // 把短路径转换成全路径 fName = [fName stringByExpandingTildeInPath]; fm = [NSFileManager defaultManager]; dirEnum = [fm enumeratorAtPath:path]; NSLog(@&quot;contents of %@&quot;, path); while ((path = [dirEnum nextObject]) != nil) &#123; NSLog(@&quot;%@&quot;, path); &#125; NSLog(@&quot;-----------------------------------&quot;); // 另一种遍历方法 dirArray = [fm contentsOfDirectoryAtPath:[fm currentDirectoryPath] error:NULL]; NSLog(@&quot;contents using contentsOfDirectoryAtPath:error:&quot;); for (path in dirArray) &#123; NSLog(@&quot;%@&quot;, path); &#125; &#125; return 0;&#125; 这两种枚举技术的不同在于：enumeratorAtPath: 方法列出了目录中的内容，包含子目录contentsOfDirectoryAtPath:error: 方法不会列出子目录内容 使用路径：NSPathUtilities.h123456789101112131415161718192021222324252627282930313233343536int main (int argc, const char *argv[]) &#123; @autorelease &#123; NSString *fName = @&quot;path.m&quot;; NSFileManager *fm= [NSFileManager defaultManager]; NSString *path, *tempdir, *extension, *homedir, *fullpath; NSArray *components; // 获取临时目录 tempdir = NSTemporaryDirectory(); NSLog(@&quot;tempoary directory is %@&quot;, tempdir); // 从当前目录中提取基本目录 path = [fm currentDirectoryPath]; NSLog(@&quot;Base dir is %@&quot;, [path lastPathComponent]); // 创建 fName 在当前目录的完整路径 fullpath = [path stringByAppendingPathComponent:fName]; NSLog(@&quot;fullpath to %@ is %@&quot;, fName, fullpath); // 获取文件扩展名 extension = [fullpath pathExtension]; NSLog(@&quot;extension for %@ is %@&quot;, fullpath, extension); // 获取用户主目录 homedir = NSHomeDirectory(); NSLog(@&quot;Your home directory is %@&quot;, homedir); // 拆分路径为各个组成部分 components = [homedir pathComponents]; for (path in components) &#123; NSLog(@&quot;%@&quot;, path); &#125; &#125; return 0;&#125; Foundation框架的NSSearchPathForDirectoriesInDomains 函数，用于获取系统的特殊目录，如 Application 和 Documents 目录。 12NSArray *dirList = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docDir = dirList[0]; 例子就是获取一个Documents目录。函数的第二个参数可以是多个值，用于指定需要列出的目录，如用户的，系统的或者所有目录。最后一个参数用于指定是否展开路径中的~字符 NSSearchPathForDirectoriesInDomains返回一组路径的数组，如果仅是查找用户的目录，这个数组只包含一个元素，如果第二个参数指定多个值，该数组会包含多个元素。 当为Ios编写程序时，NSSearchPathForDirectoriesInDomains函数第二个参数应是NSUserDoMainMask,并希望得到一个包含单个路径的数组作为返回。 常用的 iOS 目录 目录 用途 Documents (NSDocumentDirectory) 用于写入应用相关数据文件的目录。在 iOS 中写入这里的文件能够与 iTunes 共享并访问，存储在这里的文件会自动备份到 iCloud Library&#x2F;Caches (NSCachesDirectory) 用于写入应用支持文件的目录，保存应用程序再次启动需要的信息。iTunes 不会对这个目录的内容进行备份 tmp (use NSTemporaryDirectory()) 这个目录用于存放临时文件，在程序终止时需要移除这些文件。当应用程序不再需要这些临时文件时，应该将其从这个目录删除 Library&#x2F;Preferences 这个目录包含应用程序的偏好设置文件。使用 NSUserDefaults 类进行偏好设置文件的创建、读取和修改 使用 NSProcessInfo 类NSProcessInfo 类方法 方法 描述 +(NSProcessInfo *) processInfo 返回当前进程信息 -(NSArray *) arguments 以 NSString 对象数组的形式返回当前进程参数 -(NSDictionary *) environment 返回变量&#x2F;值对字典，以描述当前的环境变量，比如 PATH 和 HOME 及其值 -(int) processIdentifier 返回进程标识符，它是操作系统赋予进程的唯一数字，用于标识每个正在运行的进程 -(NSString *) processName 返回当前正在执行的进程名称 -(NSString *) globallyUniqueString 每次调用这个方法时，都返回不同的单值字符串，可以用这个字符串生成单值临时文件名 -(NSString *) hostname 返回主机系统名称 -(NSUInteger) operationsSystem 返回表示操作系统的数字 -(NSString *) operationsSystemName 返回操作系统名称 -(NSString *) operationsSystemVersionString 返回操作系统的当前版本 -(void) setProcessName: (NSString *) name 将当前进程名称设置为 name，应该谨慎的使用这个方法，因为关于进程名称存在一些假设，比如用户默认设置 深拷贝，实现 协议如果我们要实现深拷贝，就要根据&lt;NSCoping&gt;协议实现其中一两个方法。实现&lt;NSCoping&gt;协议是，类必须实现 copyWithZone: 方法来响应 copy 消息（这条 copy 消息仅将一条带有 nil 参数的 copyWithZone: 消息发送给你的类）。如果要想区分可变不可变副本，还要根据 &lt;NSMutableCoping&gt; 协议实现 mutableCopyWithZone: 方法。产生对象的可变副本并不要求被复制的对象本身也是可变的（反之亦然）。 举例子： 123456789101112131415161718192021222324252627282930...- (id) copyWithZone: (NSZone* ) zone &#123; // 如果类产生子类，那么这个方法将被继承 // 这种情况下，应该使用 [self class] // 即从该类分配一个新对象，而不是 copy 的接收者 Fraction *newFract = [[[self class] allocWithZone: zone] init]; [newFract setTo: numerator over: denominator]; return newFract;&#125;...int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; Fraction *f1 = [Fraction new]; Fraction *f2; [f1 setTo:2 over:5]; f2 = [f1 copy]; [f2 setTo:1 over:3]; [f1 print]; [f2 print]; &#125; return 0;&#125; Cocoa 和 Cocoa Touch 简介Cocoa 是一种为Mac OS X应用程序提供了丰富用户体验的框架，实际上由3个框架组成：Foundation框架、便于使用数据库存储和管理数据的Core Data框架，以及Application Kit (AppKit)框架。AppKit 框架提供了与窗口、按钮、列表等相关的类。 框架层 内核以设备驱动程序的形式提供与硬件的底层通信。它负责管理系统资源，包括调度需要执行的程序、管理内存和电源，以及执行基本的I&#x2F;O操作。 核心服务提供的支持比它上面层次更加底层或更加“核心”。例如提供对集合、网络、调试、文件管理、文件夹、内存管理、线程、时间和电源的管理。 应用层包含打印和图形渲染的支持，包括Quartz、OpenGL、和 Quicktime。 Cocoa层位于应用程序层之下。Cocoa包括Foundation、Core Data 和 AppKit框架。Foundation框架提供处理集合、字符串、内存管理、文件系统、存档等相关的类。AppKit框架提供管理视图、窗口、文档和多用户界面相关的类。 Cocoa TouchCocoa框架应用于Mac OS X桌面与笔记本电脑应用程序的开发，而Cocoa Touch框架应用于iOS设备上应用程序的开发。 Cocoa 和 Cocoa Touch 都有 Foundation 和 Core Data 框架。然而在Cocoa Touch下，UIKit代替了AppKit框架。提供了很多相同类型对象的自持。比如窗口、视图、按钮、文本域等。另外Cocoa Touch 还提供使用陀螺仪和加速器的类和触摸式界面。去掉了不需要的类。 引用参考 《Objective-C程序设计，第六版》《Objective-C维基百科》《iOS开发60分钟入门》","categories":[{"name":"Language","slug":"language","permalink":"https://mirokaku.github.io/categories/language/"}],"tags":[{"name":"Objective-C","slug":"objective-c","permalink":"https://mirokaku.github.io/tags/objective-c/"}]},{"title":"《编写高质量代码：改善 Python 程序的 91 个建议》 笔记","slug":"Writing-Solid-Python-Code-Notes","date":"2016-08-02T09:44:56.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"Writing-Solid-Python-Code-Notes/","permalink":"https://mirokaku.github.io/Writing-Solid-Python-Code-Notes/","excerpt":"之前自己学了很多次 Python，由于用不到，所以总是学完就忘掉了。刚好最近工作需要用到 Python，就借此机会好好学习了一番。Pyhton 的各种特性和风格让我甚是喜欢。不过我总是感觉自己写的代码不是那么漂亮，不够 Pythonic。所以我想通过学习一些经典建议来让我有个思路。","text":"之前自己学了很多次 Python，由于用不到，所以总是学完就忘掉了。刚好最近工作需要用到 Python，就借此机会好好学习了一番。Pyhton 的各种特性和风格让我甚是喜欢。不过我总是感觉自己写的代码不是那么漂亮，不够 Pythonic。所以我想通过学习一些经典建议来让我有个思路。 建议 1：理解 Pythonic 概念对于 Pythonic 的概念，大家心中的指南就是 Tim Peters 的 《The Zen of Python》（Python 之禅）。下面几点来自其中的内容： 美胜丑，显胜隐，简胜杂，平胜陡，疏胜密。 找到简单问题的一个方法，最好是唯一的方法（正确的解决之道）。 难以解释的实现，源自不好的主意；如有非常棒的主意，它的实现肯定易于解释。 代码风格建议参考 PEP8 和 Python 风格指南比如： 包和模块的命名采用小写、单数形式，而且短小。 包通常仅作为命名空间，如只包含空的 __init__.py 文件 建议 2：编写 Pythonic 代码 要避免劣化代码 避免只用大小写来区分不同的对象 避免使用容易引起混淆的名称 比如，重复使用已经存在于上下文中的变量名来表示不同的类型； 误用了内建名称来表示其他含义的名称而使之在当前命名空间被屏蔽； 没有构建新的数据类型的情况下使用类似于 element、list、dict等作为变量名； 使用o、l、等作为变量名。 不要害怕过长的变量名，可读性更重要 深入认识 Python 有助于编写 Pythonic 代码 全面掌握 Python 提供给我们的所有特性，包括语言特性和库特性。 学习每个 Python 新版本提供的新特性，使用 Python 推荐的惯用法来完成任务 深入学习业界公认的比较 Pythonic 的代码，比如 Flask、gevent 和 requests 等。 使用工具来达到检查和约束，比如我个人使用 Pycharm IDE 来写 Python，对代码风格的要求挺严格的... 建议 3：理解 Python 与 C 语言的不同之处我们都知道，Python 底层是用 C 语言实现的，但切忌用 C 语言的思维和风格来编写 Python 代码。尤其重要的是，不要使用之前的编程思想。 “缩进”与“{}”与 C、C++、Java 等语言使用花括号来分隔代码段不同，Python 中使用严格的代码缩进方式分隔代码块。另外，建议 Tab 替换成 4 个空格，不要混用 Tab 键和空格。 &#39; 与 &quot;C 语言中单引号 &#39; 与双引号 &quot; 由严格的区别，单引号代表一个字符，它实际对应于编译器所采用的字符集中的一个整数值。而双引号则表示字符串，默认以 \\0 结尾。但是在 Python 中，单引号与双引号没有明显区别。 三元操作符 &quot;?:&quot;三元操作符是 if...else 的简写方法，语法形式为 C ? X: Y，而在 Python 中的等价形式为 X if C else Y switch...casePython 中没有像 C 语言那样的 switch...case 分支语句。不过在 Python 中有很多替代的解决方法： C: 1234567891011121314switch(n) &#123; case 0: printf(&quot;You typed zero.\\n&quot;); break; case 1: printf(&quot;You are in top.\\n&quot;); break; case 2: printf(&quot;n is an even number.\\n&quot;); break; default: printf(&quot;Only single-digit numbers are allowed.\\n&quot;); break;&#125; Python: 12345678if n == 0: print(&quot;You typed zero.&quot;)elif n == 1: print(&quot;You are in top.&quot;)elif n == 2: print(&quot;n is an even number.&quot;)else: print(&quot;Only single-digit numbers are allowed.) 或者 123456def f(n): return &#123; 0: &quot;You typed zero.&quot;, 1: &quot;You are in top.&quot;, 2: &quot;n is an even number.&quot; &#125;.get(n, &quot;Only single-digit numbers are allowed.&quot;) Python 和其他语言的差异远不止这些。但总归一句话：不要被其他语言的思维和习惯困扰，掌握 Python 的这些和思维方式才是硬道理。 建议 4：在代码中适当添加注释Python 中有三种形式的代码注释：块注释、行注释以及文档注释（docstring）。这三种注释的惯用法大概如下几种： 使用块或行注释的时候仅仅注释那些复杂的操作、算法，还有可能别人难以理解的技巧或者不够一目了然地代码。 注释和代码隔开一定的距离，同时在块注释之后最好多留几行空白再写代码。 给外部可访问的函数和方法添加文档注释，无论简单与否。注释要清楚地描述方法的功能，并对参数、返回值以及可能发生的异常进行说明，使得外部调用它的人员仅仅看docstring就能正确使用。较为复杂的内部方法也需要进行注释。 推荐在文件头中包含 copyright 申明、模块描述等，如有比较可以考虑加入作者信息及变更记录。 建议 5：通过适当添加空行使代码布局更为优雅、合理Python 代码布局也有一些基本规则可以遵循（PEP8 中有详细规范..）： 在一组代码表达完一个完整的思路之后，应该用空白行进行间隔。如每个函数之间，导入声明、变量赋值等。 尽量保持上下文语义的易理解性 避免过长的代码行，每行最好不要超过 80 字符。 不要为了保持水平对其而使用多余的空格 （写C&#x2F;C++就有这习惯...） 空格的使用要能够在需要强调的时候竟是读者，在疏松关系的实体间起到分隔作用。 二元运算符、布尔运算的左右两边应该有空格 逗号和分号前不要使用空格 函数名和左括号之间、序列索引操作时序列名和 [] 之间不需要空格，函数的默认参数两侧不需要空格。 强调前面的操作符的时候使用空格 建议 6：编写函数的 4 个原则** 原则 1 ** 函数设计要尽量短小，嵌套层次不宜过深。** 原则 2 ** 函数申明应该做到合理、简单、易于使用。** 原则 3 ** 函数参数设计应该考虑向下兼容。** 原则 4 ** 一个函数只做一件事儿，尽量保证函数语句粒度的一致性。 Python 中函数设计的好习惯还包括：不要再函数中定义可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等。 建议 7：将常量集中到一个文件Python 中使用常量一般有以下两种方式： 通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下划线连接各个单词，如 MAX_OVERFLOW，这只是一种约定俗成的风格。 通过自定义的类实现常量功能。这要求符合“命名全部为大写”和“值一旦绑定便不可再修改”这两个条件。 12345678910111213class _const: class ConstError(TypeError): pass class ConstCaseError(ConstError): pass def __setattr__(self, name, value): if self.__dict__.has_key(name): raise self.ConstError, &quot;Can&#x27;t change const.&#123;&#125;&quot;.format(name) if not name.isupper(): raise self.ConstCaseError, &#x27;const name &quot;&#123;&#125;&quot; is not all uppercase&#x27;.format(name) self.__dict__[name] = valueimport syssys.modules[__name__] = _const() 如果上面的代码对应的模块名为 const，使用的时候只需要 import const，便可直接定义常量了，如下代码： 12import constconst.COMPANY = &quot;IBM&quot; 建议 8：利用 assert 语句来发现问题断言（assert）在很多语言中都存在，它主要为调试程序服务，能够快速方便的检查程序的异常或者发现不恰当的输入等，可防止意想不到的情况出现。 对 Python 中使用断言需要说明如下： debug 的值默认设置为 True，而且是只读的。 断言是有性能影响的。Python 可以在运行脚本时通过 -O 标识来禁用断言。比如 Python -O test.py 断言实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此食用断言需要注意以下几点： 不要滥用，这是使用断言最基本的原则。 如果 Python 本身的异常能够处理就不要再使用断言。断言没有明确的异常类型。 不要使用断言来检查用户的输入。 在函数调用后，当需要确认返回值是否合理时可以使用断言。 当条件是业务逻辑继续下去的先决条件时可以使用断言。 建议 9：数据交换值得时候不推荐使用中间变量建议 10：充分利用 Lazy evaluation 的特性Lazy evaluation 常被译为“延迟计算”或“惰性计算”，值得是仅仅在真正需要执行的时候才会计算表达式的值。充分利用 Lazy evaluation 的特性带来的好处有两个方面： 避免不必要的计算，带来性能上的提升。 节省空间，使得无限循环的数据结构成为可能。 建议 11：理解枚举替代实现的缺陷在 Python 3.4 之前，并没有提供枚举类型。所以人们充分利用 Python 的dong&#39;tai动态性这个特征，行除了美剧的各种替代实现： 使用类属性 12class Seasons: Spring, Summer, Autumn, Winter = range(4) 借助函数 12def enum(*posarg, **keysarg): return type(&quot;Enum&quot;, (object,), dict(zip(posarg, xrange(len(posarg))), **keysarg)) 使用 collections.nametuple 1Seasons = namedtuple(&#x27;Seasons&#x27;, &#x27;Spring Summer Autumn Winter&#x27;)._make(range(4)) 但是这些替代有其不合理的地方： 允许枚举值重复 支持无意义的操作，比如相加 在3.4之后，加入了枚举 Enum，其实现主要参考 flufl.enum，但两者之间存在一些差别。 建议 12：不推荐使用 type 来进行类型检查基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。任意泪的实例的 type() 返回结果都是 &lt;type &#39;instance&#39;&gt;。我们可以使用 isinstance() 函数来检测类型。 建议 13：尽量转换为浮点类型后再做除法建议 14：警惕 eval() 的安全漏洞Python 中 eval() 函数将字符串 str 当初有效的表达式来求值并返回计算结果。其函数声明如下：eval(expression[, globals[, locals]])其中参数 globals 为字典形式，locals 为任何映射对象，他们分别表示全局和局部命名空间。如果传入 globals 参数的字典中缺少 __builtins__ 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。locals 参数默认与 globals 相同，如果两者都省略的话，表达式将在 eval() 调用的环境中执行。 如果使用对象不是信任源，应该尽量避免使用 eval，在需要使用 eval 的地方可用安全性更好的 ast.literal_eval 替代。 建议 15：使用 enumerate() 获取序列迭代的索引和值建议 16：分清 &#x3D;&#x3D; 与 is 的适用场景 操作符 意义 is object identity &#x3D;&#x3D; equal is 表示的是对象标识符 (object identity)，而 &#x3D;&#x3D; 表示的意思是相等。is 的作用是用来检查对象的标识符是否一致的，也就是比较两个对象在内存中是否拥有同一块内存空间。&#x3D;&#x3D; 才是用来检验两个对象的值是否相等的，它实际调用内部 __eq__() 方法。 建议 17：考虑兼容性，尽可能使用 Unicode建议 18：构建合理的包层次来管理 module什么是包？简单说包即是目录，但是与目录不同，它除了包含常规的 Python 文件以外，还包含一个 __init__.py 文件，同时它允许嵌套。包有以下几种导入方法： 直接导入一个包import Package 导入子模块或子包，包嵌套的情况下可以进行嵌套导入 12from Package import Module1import Package.Module1 包的使用能够带来以下便利： 合理组织代码，便于维护和使用 能够有效的避免命名空间冲突 建议 19：有节制的使用 from...import 语句在使用 import 的时候注意以下几点： 一般情况下尽量优先使用 import a 形式 有节制地使用 from a import B 形式，可以直接访问 B 尽量避免使用 from a import *，因为这会污染命名空间，并且无法清晰的表示导入了哪些对象 当加载一个模块的时候，解释器实际上要完成以下动作： 在 sys.modules 中进行搜索看看模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。 如果在 sys.modules 中找不到对应的模块名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入 sys.modules 中。 加载钱确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。 对于 from...import 无节制的使用会带来什么问题： 命名空间的冲突 循环嵌套导入的问题 建议 20：优先使用 absolute import 来导入模块建议 21：i+&#x3D;1 不等于 ++iPython 中是不支持概念中 ++i 操作的。但是如果你这么写，会被 Python 解释成 +(+i)，其中 + 表示正号 建议 22：使用 with 自动关闭资源with 语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有 with 语句的代码块的执行过程如下： 计算表达式的值，返回一个上下文管理器对象。 加载上下文管理器对象的 __exit__() 方法以备后用 调用上下文管理器对象的 __enter__() 方法 如果 with 语句中设置了目标对象，则将 __enter__() 方法的返回值赋值给目标对象 执行 with 中的代码块 如果步骤5中代码正常结束，调用上下文管理器的 __exit__() 方法，其返回值直接忽略。 如果步骤5中代码执行过程中发生异常，调用上下文管理器的 __exit__() 方法，并将异常类型、值及 traceback 信息作为参数传递给 __exit__() 方法。如果 __exit__() 返回值为 False，则异常会重新抛出；如果其返回值为 True，异常被挂起，程序继续执行。 建议 23：使用 else 子句简化循环（异常处理）建议 24：遵循异常处理的几点基本原则 注意异常的粒度，不推荐在 try 中放入过多的代码。 谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。 注意异常捕获的顺序，在合适的层次处理异常。推荐的方法是将继承结构中子类异常在前面的 except 语句中抛出，而父类异常在后面的 except 语句中抛出。 使用更为友好的异常信息，遵循异常参数的规范。 建议 25：避免 finally 中可能发生的陷阱在实际应用程序开发过程中，并不推荐在 finally 中使用 return 语句或 break 进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。 建议 26：深入理解 None，正确判断对象是否为空Python 中以下数据会当作空来处理： 常量 None 常量 Flase 任何形式的数值类型零，如0、0L、0.0、0j 空的序列，如 &#39;&#39;、()、[] 空的字典，如 {} 当用户定义的类中定义了 nonzero() 方法和 len() 方法，并且该方法返回整数0或者布尔值 False 的时候。 其中常量 None 的特殊性体现在它既不是0、False，也不是空字符串，他就是一个空值对象。其数据类型为 NoneType，遵循单例模式，是唯一的，因而不能创建 None 对象。所有赋值为 None 的变量都相等，并且 None 与任何其他非 None 的对象比较结果都为 False 错误的比较 12345test_list = []if test_list is not None: print(&#x27;list is:&#x27;, test_list)else: print(&#x27;list is empty&#x27;) 正确的比较 12345test_list = []if test_list: print(&#x27;list is:&#x27;, test_list)else: print(&#x27;list is empty&#x27;) 建议 27：连接字符串应优先使用 join 而不是 +jion 的效率要高于 + 操作符jion 的时间复杂度为O(n), + 的时间复杂度为 O(n^2) 建议 28：格式化字符串时尽量使用 .format 方式而不是 %% 操作符格式化字符串时有如下几种用法： 直接格式化字符或者数值 1print(&#x27;your score is %06.1f&#x27; % 9.5) 以元组的形式格式化 12import mathprint(&#x27;the %s of a circle with radius %f is %0.3f&#x27; %(&#x27;circumference&#x27;, 3, math.pi*radius*2)) 以字典的形式格式化 12itemdict = &#123;&#x27;itemname&#x27;: &#x27;circumference&#x27;, &#x27;radius&#x27;: 3, &#x27;value&#x27;: math.pi*radius*2&#125;print(&#x27;the %(itemname)s of a circle with radius %(radius)f is %(value)0.3f&#x27; % itemdict) .format 方式格式化字符串的基本语法为：[[填充符] 对齐方式][符号][#][0][宽度][,][.精确度][转换类型]其中填充符可以是除了 &#123; 和 &#125; 符号之外的任意符号。 对其方式 解释 &lt; 表示左对其，是大多数对象为默认的对其方式 &gt; 表示右对其，数值默认的对其方式 &#x3D; 仅对数值类型有效，如果有符号的话，在符号后数值前进行填充，如-0029 ^ 居中对其，用空格进行填充 符号 解释 + 正数前加 +，负数前加 - - 正数前不加符号，负数前加 -，为数值的默认形式 空格 正数前加空格，负数前加 - .format 常用用法： 使用位置符号 使用名称 通过属性 123456789101112class Customer(object): def __init__(self, name, gender, phone): self.name = name self.gender = gender self.phone = phone def __str__(self): # 通过 str() 函数返回格式化的结果 return &#x27;Customer(&#123;self.name&#125;,&#123;self.gender&#125;,&#123;self.phone&#125;)&#x27;.format(self=self)str(Customer(&#x27;Lisa&#x27;, &#x27;Female&#x27;, &#x27;67889&#x27;))&#x27;Customer(Lisa, Female, 67889)&#x27; 格式化元组的具体项 1234point = (1,3)&#x27;X:&#123;0[0]&#125;;Y:&#123;0[1]&#125;&#x27;.format(point)&#x27;X:1;Y:3&#x27; 使用 .format 的理由： format 方式在使用上较 % 操作符更为灵活 format 方式可以方便的作为参数传递 % 最终会被 .format 方式所替代 % 方法在某些情况下使用时需要特别小心 建议 29：区别对待可变对象和不可变对象数字、字符串、元组属于不可变对象字典、列表、字节数组属于可变对象 看一个经典例子： 1234567891011121314151617181920212223242526272829303132class Student(object): def __init__(self, name, coures=[]): self.name = name self.course = coures def add_course(self, course_name): self.course.append(course_name) def print_course(self): for item in self.course: print(item)def main(): stu_a = Student(&#x27;Wang yi&#x27;) stu_a.add_course(&#x27;English&#x27;) stu_a.add_course(&#x27;Math&#x27;) print(stu_a.name + &quot;&#x27;s course:&quot;) stu_a.print_course() print(&#x27;----------------------------&#x27;) stu_b = Student(&#x27;Li san&#x27;) stu_b.add_course(&#x27;Chinese&#x27;) stu_b.add_course(&#x27;Physics&#x27;) print(stu_b.name + &quot;&#x27;s course:&quot;) stu_b.print_course()if __name__ == &#x27;__main__&#x27;: main() 结果 123456789101112C:\\Users\\MeeSong\\AppData\\Local\\Programs\\Python\\Python35\\python.exe C:/Users/MeeSong/Desktop/test/test.pyWang yi&#x27;s course:EnglishMath----------------------------Li san&#x27;s course:EnglishMathChinesePhysicsProcess finished with exit code 0 看到没，结果与预想的并不一样。我们通过 id(stu_a.course) 和 id(stu_b.course) (id 是查看对象的内存标识的，即内存地址) 发现两个结果是一样的，说明两个list对象指的是同一块地址。但 stu_a 和 stu_b 本身却是两个不同的对象。在实例化两个对象的时候，这两个对象被分配了不同的内存空间，并且调用 init() 函数进行了初始化。但由于 init() 函数的第二个参数是个默认参数，默认桉树在函数被调用的时候仅仅被评估一次，以后都会使用第一次评估的结果，因此实际上对象空间里面 course 所指向的是同一个list地址。 我们改成这样就好了 123456789101112class Student(object): def __init__(self, name, coures=None): self.name = name self.course = coures if coures else [] def add_course(self, course_name): self.course.append(course_name) def print_course(self): for item in self.course: print(item) 另外，切片操作相当于浅拷贝。 12345678910111213&gt;&gt;&gt; b[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; id(a[0])2279905391312&gt;&gt;&gt; id(b[0])2279905391312&gt;&gt;&gt; id(a)2279910237896&gt;&gt;&gt; id(b)2279910245384 对于不可变对象，当我们对其进行相关操作的时候，Python 实际上仍然保持原来的值，并重新创建一个新的对象。比如字符串操作 12345678&gt;&gt;&gt; s1 = &#x27;123&#x27;&gt;&gt;&gt; s2 = s1&gt;&gt;&gt; id(s2)2279910241368&gt;&gt;&gt; id(s1)2279910241368&gt;&gt;&gt; id(s1[:1])2279905395408 建议 30：[]、() 和 {}：一致的容器初始化形式建议使用列表解析来初始化，即列表推导式（或元组和字典）列表推导式的语法为：[expr for iter_item in iterable if cond_expr]元组推导式的语法为：(expr for iter_item in iterable if cond_expr)集合推导式的语法为：&#123;expr for iter_item in iterable if cond_expr&#125;字典推导式的语法为：&#123;exprk:exprv for iter_item in iterable if cond_expr&#125; 12&gt;&gt;&gt; [v**2 if v%2 == 0 else v+1 for v in [2,3,4,-1] if v&gt;0][4, 4, 16] 列表推导式非常灵活： 支持多重嵌套 支持多重迭代 列表推导式的语法中的表达式可以是简单表达式，也可以是复杂表达式，甚至是函数 列表推导式语法中的iterable可以是任意可迭代对象 为什么推荐俺在需要生成列表的时候使用列表推导式呢？ 使用列表推导式更为直观清晰，代码更为简洁 列表推导式的效率更高 建议 31：记住函数传参既不是传值也不是传引用先看两张图 对于在Python函数参数是传值还是传引用这个问题：正确叫法应该是传对象或者说传对象的引用。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，而对于不可变对象， 由于并不能真正被修改，因此修改往往是通过生成一个新对象然后赋值来实现的 建议 32： 警惕默认参数潜在的问题这个问题同 建议 29：区别对待可变对象和不可变对象 的例子 建议 33：慎用变长参数Python 支持可变长度的参数列表，可以通过在函数定义的时候使用 *args 和 **kwargs 这两个特殊语法来实现。 使用 *args 来实现可变参数列表： *args 用于接收一个包装为元组形式的参数列表来传递非关键字参数，参数个数可以任意。 使用 **kwargs 接受字典形式的关键字参数列表，其中字典的键值对分别表示不可变参数的参数名和值 为什么要慎用可变长度参数呢： 使用过于灵活 如果一个函数的参数列表很长，虽然可以通过使用 *args 和 **kwargs 来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。 可变长参数适合在下列情况下使用： 为函数添加一个装饰器 如果参数的数目不确定，可以考虑使用变长参数 用来实现函数的多态或者在继承情况下子类需要调用父类的某些方法的时候 建议 34：深入理解 str() 和 repr() 的区别函数 str() 和 repr() 都可以将 Python 中的对象转换为字符串，他们的使用及输出都非常相似 区别主要有以下几点： 两者之间的目标不同：str() 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型;而 repr() 面向的是Python解释器，或者说开发人员，其目的是准确性，返回值表示 Python 解释器内部的含义，常作为编程人员 debug 用途 在解释器中输入a时，默认调用 repr() 函数，而 print(a) 则调用 str() 函数 repr() 的返回值一般可以用 eval() 函数来还原对象，通常来说有这个等式：obj == eval(repr(obj)) 这两个方法分别调用内建的 __str__() 和 __repr__() 方法，一般来说在类中都应该定义 __repr__() 方法，而 __str__() 方法则为可选，当可读性比准确性更重要的时候应该考虑定义 __str__() 方法。如果类中没有定义 __str__() 方法，则默认会使用 __repr__() 方法的结果来返回对象的字符串形式。用户实现 __repr__() 方法的时候最好保证其返回值可以用 eval() 方法使对象重新还原 建议 35：分清 staticmenthod 和 classmethod 的适用场景静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数 类方法能够根据不同的类型返回对应的类的实例既不跟特定的实例相关，也不跟特定的类相关的时候，用静态方法更合适 建议 36：掌握字符串的基本用法小技巧Python 遇到未闭合的小括号时会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接到一起。 12345&gt;&gt;&gt; s = (&#x27;SELECT * &#x27;... &#x27;FROM atable &#x27;... &#x27;WHERE afield=&quot;value&quot;&#x27;)&gt;&gt;&gt; print(s)SELECT * FROM atable WHERE afield=&quot;value&quot; 性质判定 方法 描述 isalnum() 是否只是数字或字母 isalpha() 是否字母 isdigit() 是否数字 islower() 是否小写 isupper() 是否大写 isspace() 是否空白符 istitle() 是否标题化的，即每个单词首字母是否大写 startswith(prefix[,start[,end]]) 是否以prefix开头，可范围内检查，prefix可接受tuple类型的实参 endswith(suffix[,start[,end]]) 是否以suffix结尾，可范围内检查，suffix可接收tuple类型的实参 查找 方法 描述 count(sub[,start[,end]]) 查找sub在字符串中出现的次数，这个数值在调用replace方法时用得着 find(sub[,start[,end]]) 查找sub在字符串中的位置，找不到时返回-1 index(sub[,start[,end]]) 同find，不过找不到会抛出 ValueError 异常，另外对于是否包含字串，更推荐使用 in 和 not in 操作符 rfind(sub[,start[,end]]) 同find，从右侧开始 rindex(sub[,start[,end]]) 同index，从右侧开始 替换 方法 描述 replace(old, new[,count]) 把字符串中的old替换为new，count为最多替换次数 translate(table[,deletechars]) 根据table转换字符串的字符，可以由string.maketrans(frm,to)生成；deletechars为过滤掉的字符 分切 方法 描述 partition(sep) 它接受一个字符串参数，并返回一个3个元素的 tuple 对象。如果sep没出现在母串中，返回值是 (sep, ‘’, ‘’)；否则，返回值的第一个元素是 sep 左端的部分，第二个元素是 sep 自身，第三个元素是 sep 右端的部分。 rpartition(sep) splitlines([keepends]) split([sep [,maxsplit]]) 参数 maxsplit 是分切的次数，即最大的分切次数，所以返回值最多有 maxsplit+1 个元素。 rsplit([sep[,maxsplit]]) 不过有一个需要注意的地方对于字符串s、s.split() 和 s.split(&#39; &#39;) 返回值是不同的 1234&gt;&gt;&gt; &#x27; hello world!&#x27;.split()[&#x27;hello&#x27;, &#x27;world!&#x27;]&gt;&gt;&gt; &#x27; hello world!&#x27;.split(&#x27; &#x27;)[&#x27;&#x27;, &#x27;hello&#x27;, &#x27;&#x27;, &#x27;world!&#x27;] 产生差异的原因在于当忽略 sep 参数或sep参数为 None 时与明确给 sep 赋予字符串值时 split() 采用两种不同的算法。对于前者，split() 先去除字符串两端的空白符，然后以任意长度的空白符串作为界定符分切字符串（即连续的空白符串被当作单一的空白符看待）；对于后者则认为两个连续的 sep 之间存在一个空字符串。 连接join() 函数的高效率（相对于循环相加而言），使它成为最值得关注的字符串方法之一。它的功用是将可迭代的字符串序列连接成一条长字符串，如： 123456&gt;&gt;&gt; conf = &#123;&#x27;host&#x27;:&#x27;127.0.0.1&#x27;,... &#x27;db&#x27;:&#x27;spam&#x27;,... &#x27;user&#x27;:&#x27;sa&#x27;,... &#x27;passwd&#x27;:&#x27;eggs&#x27;&#125;&gt;&gt;&gt; &#x27;;&#x27;.join(&quot;%s=%s&quot;%(k, v) for k, v in conf.iteritems())&#x27;passswd=eggs;db=spam;user=sa;host=127.0.0.1&#x27; 变形 方法 描述 lower() 转小写 upper() 转大写 capitalize() 把字符串的第一个字符大写 swapcase() 翻转 string 中的大小写 title() 返回&quot;标题化&quot;的 string,就是说所有单词都是以大写开始，其余字母均为小写 title()函数是比较特别的，它的功能是将每一个单词的首字母大写，并将单词中的非首字母转换为小写（英文文章的标题通常是这种格式）。 12&gt;&gt;&gt; &#x27;hello world!&#x27;.title()&#x27;Hello World!&#x27; 因为title() 函数并不去除字符串两端的空白符也不会把连续的空白符替换为一个空格，所以建议使用string 模块中的capwords(s)函数，它能够去除两端的空白符，再将连续的空白符用一个空格代替。 1234&gt;&gt;&gt; &#x27; hello world!&#x27;.title()&#x27; Hello World!&#x27;&gt;&gt;&gt; string.capwords(&#x27; hello world!&#x27;)&#x27;Hello World!&#x27; 删减 方法 描述 strip([chars]) 在 string 上执行 lstrip()和 rstrip() lstrip([chars]) 截掉 string 左边的空格 rstrip([chars]) 删除 string 字符串末尾的空格. *strip()函数族用以去除字符串两端的空白符，空白符由string.whitespace常量定义。 填充 方法 描述 center(width[, fillchar]) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串， fillchar 参数指定了用以填充的字符，默认为空格 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 rjust(width[, fillchar]) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 expandtabs([tabsize]) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 编码 方法 描述 encode([encoding[,errors]]) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是&#39;ignore&#39;或者&#39;replace&#39; decode([encoding[,errors]]) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 &#39;ignore&#39; 或 者&#39;replace&#39; 建议 37：按需选择 sort() 或者 sorted()sorted(iterable[, cmp[, key[, reverse]]])s.sort([cmp[, key[, reverse]]]) cmp 为用户定义的任何比较函数，函数的参数为两个可比较的元素（来自iterable或者list），函数根据第一个参数与第二个参数的关系依次返回 -1、0、+1（第一个参数小于第二个参数则返回负数）。该参数默认值为None。 key 是带一个参数的函数，用来为每个元素提取比较值，默认为None（即直接比较每个元素） reverse 表示结果是否反转 sort() 与 sorted() 之间的比较： 相比于 sort()，sorted() 使用范围更为广泛 当排序对象为列表的时候两者适合的场景不同。sorted() 函数会返回一个排序后的立标，原有列表保持不变；而 sort() 函数会直接修改原有列表，函数返回为 None 无论是 sort() 还是 sorted() 函数，传入参数 key 比传入参数 cmp 效率要高。 sorted() 函数功能非常强大，使用它可以方便的针对不同的数据结构进行排序，从而满足不同需求。对于 itemgetter 的使用，参见 python operator.itemgetter函数与sorted的妙用 对字典进行排序 12345&gt;&gt;&gt; phonebook = &#123;&#x27;Linda&#x27;:&#x27;7750&#x27;, &#x27;Bob&#x27;:&#x27;9345&#x27;, &#x27;Carol&#x27;:&#x27;5834&#x27;&#125;&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; sorted_pb = sorted(phonebook.items(), key=itemgetter(1))&gt;&gt;&gt; sorted_pb[(&#x27;Carol&#x27;, &#x27;5834&#x27;), (&#x27;Linda&#x27;, &#x27;7750&#x27;), (&#x27;Bob&#x27;, &#x27;9345&#x27;)] 多维 list 排序 1234&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; gameresult = [[&#x27;Bob&#x27;, 95.00, &#x27;A&#x27;], [&#x27;Alan&#x27;, 86.0, &#x27;C&#x27;], [&#x27;Mandy&#x27;, 82.5, &#x27;A&#x27;], [&#x27;Rob&#x27;, 86, &#x27;E&#x27;]]&gt;&gt;&gt; sorted(gameresult, key=itemgetter(2,1))[[&#x27;Mandy&#x27;, 82.5, &#x27;A&#x27;], [&#x27;Bob&#x27;, 95.0, &#x27;A&#x27;], [&#x27;Alan&#x27;, 86.0, &#x27;C&#x27;], [&#x27;Rob&#x27;, 86, &#x27;E&#x27;]] 字典中混合 list 排序 12345678910mydict = &#123;&#x27;Li&#x27;: [&#x27;M&#x27;, 7], &#x27;Zhang&#x27;: [&#x27;E&#x27;, 2], &#x27;Wang&#x27;: [&#x27;p&#x27;, 3], &#x27;Du&#x27;: [&#x27;c&#x27;, 2], &#x27;Ma&#x27;: [&#x27;c&#x27;, 9], &#x27;Zhe&#x27;: [&#x27;H&#x27;, 7]&#125;print(sorted(mydict.items(), key=lambda item: itemgetter(1)(itemgetter(1)(item))))[(&#x27;Zhang&#x27;, [&#x27;E&#x27;, 2]), (&#x27;Du&#x27;, [&#x27;c&#x27;, 2]), (&#x27;Wang&#x27;, [&#x27;p&#x27;, 3]), (&#x27;Li&#x27;, [&#x27;M&#x27;, 7]), (&#x27;Zhe&#x27;, [&#x27;H&#x27;, 7]), (&#x27;Ma&#x27;, [&#x27;c&#x27;, 9])] list 中混合字典排序 1234567gameresult = [&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;wins&#x27;: 10, &#x27;losses&#x27;: 3, &#x27;rating&#x27;: 75.00&#125;, &#123;&#x27;name&#x27;: &#x27;David&#x27;, &#x27;wins&#x27;:3, &#x27;losses&#x27;: 5, &#x27;rating&#x27;: 57.00&#125;, &#123;&#x27;name&#x27;: &#x27;Carol&#x27;, &#x27;wins&#x27;:4, &#x27;losses&#x27;: 5, &#x27;rating&#x27;: 57.00&#125;]print(sorted(gameresult, key=itemgetter(&#x27;rating&#x27;, &#x27;name&#x27;)))[&#123;&#x27;wins&#x27;: 4, &#x27;name&#x27;: &#x27;Carol&#x27;, &#x27;losses&#x27;: 5, &#x27;rating&#x27;: 57.0&#125;, &#123;&#x27;wins&#x27;: 3, &#x27;name&#x27;: &#x27;David&#x27;, &#x27;losses&#x27;: 5, &#x27;rating&#x27;: 57.0&#125;, &#123;&#x27;wins&#x27;: 10, &#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;losses&#x27;: 3, &#x27;rating&#x27;: 75.0&#125;] 建议 38： 使用 copy 模块进行深拷贝对象概念： 浅拷贝（shallow copy）：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。浅拷贝的实现方式与多种，如工厂函数、切片操作、copy模块中的copy操作。 深拷贝（deep copy）：也是构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。 建议 39：使用 Counter 进行计数统计Counter 类是自 Python2.7 起增加的，属于字典的子类，是一个容器对象，主要用来统计散列对象。 建议 40：深入掌握 ConfigParser建议 41：使用 argparse 处理命令行参数另外，还有更先进好用的 docopt，不过暂时还没加入标准库。详见 docopt 建议 42：使用 pandas 处理大型 CSV 文件CSV(Comma Separated Values) 作为一种逗号分隔符型值的纯文本格式文件，在实际应用中经常用到，如数据库的导入导出、数据分析中记录的存储等。 CSV 处理相关 API： &#39;reader(csvfile[, dialect&#x3D;&#39;excel&#39;][, fmtparam])&#39;，主要用于 CSV 文件的读取，返回一个 reader 对象用于在 CSV 文件内容上进行行迭代 &#39;csv.writer(csvfile, dialect&#x3D;&#39;excel&#39;, **fmtparams)&#39;，用于写入 CSV 文件。 &#39;csv.DictReader(csvfile, fieldnames&#x3D;None, restkey&#x3D;None, restval&#x3D;None, dialect&#x3D;&#39;excel&#39;, *args, **kwds)&#39;，将读入的信息映射到一个字典中去 &#39;csv.DictWrite(csvfile, fieldnames, restval&#x3D;&#39;&#39;, extrasaction&#x3D;&#39;raise&#39;, dialect&#x3D;&#39;excel&#39;, *args, **kwds)&#39;，用于支持字典的写入。 但是在处理大型 CSV 文件，上面API会抛出 MemoryError 异常。 Pandas 即 Python Data Analysis Library，是为了解决数据分析而创建的第三方工具，支持多种文件格式处理，包括 CSV、HDF5、HTML 等，能够提供高效的大型数据处理。 Series：它是一种类似数据的带索引的一维数据结构，支持的类型与 NumPy 兼容。 DataFrame：类似于电子表格，其数据为排好序的数据列的集合，每一列都可以是不同的数据类型，它类似于一个二维数据结构，支持行和列的索引。 建议 43：一般情况使用 ElementTree 解析 XML 使用简单 内存上消耗明显低于 DOM 解析。 支持 XPath 查询 建议 44：理解模块 pickle 优劣pickle 估计是最通用的序列化模块了，它还有个 C 语言的实现 cPickle，相比 pickle 来说具有较好的性能，其速度大概是 pickle 的 1000 倍，除了不能被继承之外，它们两者的使用基本上区别不大 pickle 中最主要的两个函数对儿为 dump() 和 load()，分别来进行对象的序列化和反序列化： pickle.dump(obj, file[, protocol])：序列化数据到一个文件描述符。 pickle.load(file)：表示把文件中的对象恢复为原来的对象。 pickle 模块的优点： 接口简单，容易使用 pickle 的存储格式具有通用性，能够被不同平台的 Python 解析器共享 支持的数据类型广泛 pickle 模块是可扩展的 能够自动维护对象间的引用，如果一个对象上存在多个引用，pickle 后不会改变对象间的引用 pickle 模块的限制： pickle 不能保证操作的原子性 pickle 存在安全性问题 pickle 协议是 Python 特性的，不同语言之间的兼容性难以保证 建议 45：序列化的另一个不错的选择——JSON相比 pickle，JSON 具有以下优势： 使用简单，支持多种数据类型，仅存在以下两大数据结构： 名称 &#x2F; 值 对儿的集合 （dict） 值的有序列表 （list） 存储格式可读性更为友好，容易修改。 JSON 支持跨平台跨语言 具有较强的扩展性，JSON 模块还提供了编码（JSONEncoder）和解码类（JSONDecoder），以便用户对其默认不支持的序列化类型进行扩展 建议 46：使用 traceback 获取栈信息常用方法： traceback.print_exception(type, value, traceback[, limit[, file]])，根据 limit 的设置打印栈信息，file 为 None 的情况下定位到 sys.stderr，否则写入到文件；其中 type、value、traceback 这3个参数对应的值可以从 sys.exc_info() 中获取 traceback.print_exc(limit[, file])，为 print_exception 函数的缩写，不需要传入 type、value、traceback 这三个参数 traceback.format_exc([limit])，与 print_exc() 类似，区别在于返回形式为字符串 traceback.extract_stack([file[, limit]])，从当前栈帧中提取 trace 信息。 建议 47：使用 logging 记录日志信息使用见 Python的日志系统 建议 48：使用 threading 模块编写多线程程序实际应用中推荐使用 threading 模块而不是 thread 模块： threading 模块对同步原语的支持更为完善和丰富 threading 模块在主线程和子线程交互上更为友好 thread 模块不支持守护线程 python3 中已经不存在 thread 模块 使用见 Python中使用线程的技巧 建议 49：使用 Queue 使多线程编程更安全建议 50：利用模块实现单例模式建议 51：用 mixin 模式让程序更加灵活建议 52：用发布订阅模式实现松耦合建议 53：用状态模式美化代码建议 54：理解 built-in objectsPython 一切皆对象。自 Python2.2 之后，为了弥补内建类型和古典类之间的鸿沟，引入了新式类。新式类中，object 是所有内建类型的积累，用户定义的类可以继承自 object 也可继承自内建类型。 这里的鸿沟指的是：在 2.2 版本之前，类和类型并不统一，如 a 是古典类 ClassA 的一个实例，那么 a.__class__ 返回 &#39;class__main__ClassA&#39;，type(a) 返回 &lt;type&#39;instalce&#39;&gt;。当引入新类后，比如 ClassB 是个新类，b 是 ClassB 的实例，b.class 和 type(b) 都是返回 &#39;class__main__.ClassB&#39; 新式类相对于古典类来说有很多优势：能够基于内建类型构建新的用户类型，支持 property 和描述符特性等。 建议 55：__init__() 不是构造方法实际上 __init__() 并不是真正意义上的构造方法，__init__()方法所做的工作是在类的对象创建好之后进行变量的初始化。__new__()方法才会真正创建实例，是类的构方法。 两个方法之间的不同点，总结如下： object.__new__(cls[, args...])：其中 cls 代表类，args 为参数列表 object.__init__(self[, args...])：其中 self 代表实例对象，args 为参数列表 __new__() 方法是静态方法，__init__() 为实例方法 __new__() 方法一般需要返回类的对象，当返回类的对象时将会自动调用 __init__() 方法进行初始化，如果没有对象返回，则 __init__() 方法不会被调用。 __init__() 方法不需要显式返回，默认为 None，否则会在运行时抛出 TypeError 当需要控制实例创建的时候可使用 __new__() 方法，而控制实例初始化的时候用 __init__() 方法 一般情况下不需要覆盖 __new__() 方法，但当子类继承自不可变类型，如 str、int、unicode 或者 tuple 的时候，往往需要覆盖该方法。 当需要覆盖 __new__() 和 __init__() 方法的时候这两个方法的参数必须保持一致，如果不一致将会导致异常。 什么特殊情况下需要覆盖 __new__() 方法呢？ 当类继承不可变类型且默认的 __new__() 方法不能满足需求的时候。 用来实现工厂模式或者单例模式或者进行元类便哼的时候 作为用来初始化的 __init__() 方法在多继承的情况下，子类的 __init__() 方法如果不显式调用父类的 __init__() 方法，则父类的 __init__() 方法不会被调用。 建议 56：理解名字查找机制在 Python 中，所有所谓的变量其实都是名字，这些名字指向一个或者多个 Python 对象。 Python 中有 4 中作用域： 局部作用域：一般来说函数的每次调用都会创建一个新的本地作用于，拥有新的命名空间。 全局作用域：定义在Python模块文件中的变量名拥有全局作用域，需要注意的是这里的全局仅限单个文件，即在一个文件的顶层的变量名仅在这个文件内可见，并非所有的文件，其他文件中想使用这些变量必须先导入文件对应的模块 嵌套作用域：一般在多重函数嵌套的情况下才会考虑到，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用 global 进行声明也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。 内置作用域：通过一个标准库名为 __builtin__ 的模块来实现的。 Python 的名字查找机制如下： 在最内层范围内查找，一般而言就是函数内部，即在 locals() 里面查找 在模块内查找，即在 globals() 里面查找 在外层查找，即在内置模块中查找，也就是在 __builtin__ 中查找 若要修改全局变量，在 Python3 中可以使用 nonlocal 来声明变量 建议 57：为什么需要 self 参数 Python 在当初设计的时候借鉴了其他语言的一些特征，如 Moudla-3 中方法会显示的在参数列表中传入 self。 Python 语言本身的动态性决定了使用 self 能够带来一定便利。 在存在同名的局部变量以及实例变量的情况下使用 self 使得实例变量更容易被区分 建议 58：理解 MRO 与多继承建议 59：理解描述符机制建议 60：区别 __getattr__() 和 __getattribute__() 方法__getattr__() 和 __getattribute__() 都可以用作实例属性的获取和拦截（仅对实例属性）__getattr__() 适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在__getattribute__() 对于所有属性的访问都会调用该方法，仅应用于新式类 覆盖这些方法时，几点注意事项： 避免无穷递归。例如： 12345def __getattribute__(self, attr): try: return self.__dict__[attr] except KeyError: return &#x27;default&#x27; 属性的访问调用的是覆盖的 __getattribute__() 方法，而该方法中 self.__dict__[attr] 又要调用 __getattribute__(self, attr)，于是产生了无穷递归。正确方法是使用 super(obj, self).__getattribute__(attr)。 访问未定义的属性。如果在 __getattribute__() 方法中不抛出 AttributeError 异常或者显示返回一个值，则会返回 None，此时可能会影响到程序的实际运行预期 覆盖了 __getattribute__() 方法之后，任何属性的访问都会调用用户定义的 __getattribute__() 方法，性能上会有损耗 覆盖的 __getattr__() 方法如果能够动态处理事先未定义的属性，可以更好的实现数据隐藏。 __getattribute__() 总是会被调用，而 __getattr__() 只有在 __getattribute__() 中引发异常的情况下才会被调用。 建议 61：使用更为安全的 propertyproperty 是用来实现属性可管理性的 built-in 数据类型，其实质是一种特殊的数据描述符。它和普通描述符的区别在于：普通描述符提供的是一种较为低级的控制属性访问的机制，而 property 是它的高级应用，它以标准库的形式提供描述符的实现，其签名形式为：property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute property 的优势可以简单概括为以下几点： 代码更简洁，可读性更强。 更好的管理属性的访问 代码可维护性更好 控制属性访问权限，提高数据安全性 建议 62：掌握 metaclass什么是元类？ 元类是关于类的类，是类的模板 元类是用来控制如何创建类的，正如类是创建对象的模板一样 元类的实例为类，正如类的实例为对象 元类需要注意的几点： 区别类方法与元方法 多继承需要严格限制，否则会产生冲突 元类用来指导类的生成，元方法可以从元类或者类中调用，不能从类的实例中调用，而类方法既可以从类中调用，也可以从类的实例中调用。 建议 63： 熟悉 Python 对象协议 用以比较大小的协议，这个协议依赖于 __cmp__() 方法，相等返回0，小于返回负值，大于返回正值。还有其他诸如 __eq__()、__ne__()、__lt__()、__gt__() 等方法来实现相等、不等、小于和大于的判定。这也就是 Python 对 &#x3D;&#x3D;、!&#x3D;、&lt; 和 &gt; 等操作符的进行重载的支撑机制 数值类型相关的协议 分类 方法 操作符 &#x2F; 函数 说明 数值运算符 __add__ + 加 | `__sub__` | - | 减 | `__mul__` | * | 乘 | `__div__` | / | 除 | `__floordiv__` | // | 整除 | `__truediv__` | / | 真除法，当 `__future__.division` 起作用时调用，否则调用 `__div__` | `__pow__` | ** | 幂运算 | `__mod__` | % | 模运算 | `__divmod__` | divmod() | 余、除 位运算符 | __lshift__ | &lt;&lt; | 向左移位 | __rshift__ | &gt;&gt; | 向右移位 | __and__ | &amp; | 与 | __or__ | or 那个符号 | 或 | __xor__ | ^ | 异或 | __invert__ | ~ | 非运算赋值符 | __iadd__ | +&#x3D; | | __isub__ | -&#x3D; | | __imul__ | *&#x3D; | | __idiv__ | &#x2F;&#x3D; | | __ifloordiv__ | &#x2F;&#x2F;&#x3D; | | __itruediv__ | &#x2F;&#x3D; | | __ipow__ | **&#x3D; | | __imod__ | %&#x3D; | | __ilshift__ | &lt;&lt;&#x3D; | | __irshift__ | &gt;&gt;&#x3D; | | __iand__ | &amp;&#x3D; | | __ior__ | |&#x3D; | | __ixor__ | ^&#x3D; |其他 | __pos__ | + | 正 | __neg__ | - | 负 | __abs__ | abs() | 绝对值 容器类型协议。__len__() 支持内置函数 len()__getitem__()、__setitem__()、__delitem__() 对应读、写、删除__iter__() 对应迭代器__reversed__() 支持内置函数 reversed()__contains__() 支持使用 in 和 not in 运算符 可调用对象协议 __call__() 与可调用对象差不多的，还有一个可哈希对象，他是用过 __hash__() 方法来支持 hash() 这个内置函数的 描述符协议和属性交互协议（__getattr__()、__setattr__()、__delattr__()） 上下文管理器协议这个协议通过 __enter__() 和 __exit__() 这两个方法来实现对资源的清理。 建议 64：利用操作符重载实现中缀语法可以安装 pipe 来实现 pip install pipe 建议 65：熟悉 Python 的迭代器协议迭代器协议归纳： 实现 __iter__() 方法，返回一个迭代器 实现 next() 方法，返回当前的元素，并指向下一个元素的为止，如果当前为止已无元素，则抛出 StopIteration 异常 建议 66：熟悉 Python 的生成器如果一个函数使用了 yield 语句，那么它就是一个生成器函数。每一个生成器函数调用之后，它的函数体并不执行，而是到第一次调用 next() 的时候才开始执行，执行到 yield 表达式为止。 建议 67：基于生成器的协程及 greenlet建议 68：理解 GIL 的局限性针对这种，不建议高密集的计算使用多线程，建议堵塞I&#x2F;O的使用.. 建议 69：对象的管理与垃圾回收Python 使用引用计数器的方法来管理内存中的对象，即针对每一个对象维护一个引用计数值来表示该对象当前有多少个引用。引用计数算法最明显的缺点是无法解决循环引用的问题，即两个对象相互引用。 我们可以使用自带的 gc 模块来跟踪对象的 “入引用” 和 “出引用”。 建议 70：从 PyPi 安装包PyPi 全称 Python Package Index，直译过来就是 Python包索引，它是Python编程语言的软件仓库。 建议 71：使用 pip 和 yolk 安装、管理包建议 72：做 paster 创建包建议 73：理解单元测试概念单元测试带来以下好处： 减少了潜在 bug，提高了代码的质量。 大大缩减软件修复的成本。 为集成测试提供基本保障 有效的单元测试应该从以下几个方面考虑： 测试先行，遵循单元测试步骤。 创建测试计划 编写测试用例，准备测试数据 编写测试脚本 边界被测试代码，在代码完成之后执行测试脚本 修正代码缺陷，重新测试直到代码可接受为止。 遵循单元测试基本原则 一致性 原子性 单一职责 隔离性 使用单元测试框架 unittest。unittest 相关的概念主要有以下四个： 测试固件。测试相关的准备工作和清理工作，基于类 TestCase 差个内奸测试固件的时候通常需要重新实现 setUp() 和 tearDown() 方法。 测试用例。最小的测试单元，通常基于 TestCase 构建 测试用例集，测试用例的集合，使用 TestSuite 类来实现 测试运行器，控制和驱动整个单元测试过程，一般使用 TestRunner 类作为测试用例的基本执行环境，常用的运行器为 TextTestRunner，它是 TestRunner 的子类，以文字方式运行测试并报告结果。 建议 74：为包编写单元测试 nose建议 75：利用测试驱动开发提高代码的可测性测试驱动开发流程： 编写部分测试用例，并运行测试 如果测试用过，则回到测试用例编写的步骤，继续添加新的测试用例 如果测试失败，则修改代码直到测试通过 当所有测试用例编写完成并通过测试之后，再来考虑对代码进行重构 关于测试驱动开发和提高代码可测性方面有几点说明： TDD 只是手段而不是目的，因此在实践中尽量只验证正确的事情，并且每次仅仅验证一件事儿。 测试驱动开发本身就是一门学问，不要指望通过一个简单的例子就掌握其精髓。 代码的不可测性可以从以下几个方面考量：实践 TDD 困难；外部依赖太多；需要写很多模拟代码才能完成测试；职责太多导致功能模糊；内部状态过多且没有办法去操作和维护这些状态；函数没有明显返回或者参数过多；低内聚高耦合等等 建议 76：使用 Pylint 检查代码风格我使用 PyChrame 貌似内置..严格遵循 PEP8 标准 建议 77：进行高效的代码审查建议 78：将包发布到 PyPI建议 79：了解代码优化的基本原则 优先保证代码是可工作的 权衡优化的代价 定义性能指标，集中力量解决首要问题 不要忽略可读性 建议 80：借助性能优化工具例如 Pypy 建议 81：利用 cProfile 定位性能瓶颈cProfile 的统计结果及其各项意义 统计项 意义 ncalls 函数的被调用次数 tottime 函数总计运行时间，不含调用的函数运行时间 percall 函数运行一次的平均时间，等于 tottime&#x2F;ncalls cumtime 函数总计运行时间，含调用的函数运行时间 percall 函数一次运行的平均时间，等于 cumtime&#x2F;ncalls filename:lineno(function) 函数所在的文件名、函数行号、函数名 Stats 提供了对 cProfile 输出结果进行排序、输出控制等功能。 Stats 函数以及对应作用 函数 函数的作用 strip_dirs() 用以除去文件名前面的路径信息 add(filename[,...]) 把 profile 的输出文件加入 Stats 实例中统计 dump_stats(filename) 把 Stats 的统计结果保存到文件 sort_stats(key[,...]) 用以排序 Profile 的输出 reverse_order() 把 Stats 实例里的数据反序重排 print_stats([restriction, ...]) 把 Stats 报表输出到 stdout print_callers([restriction, ...]) 输出调用了指定的函数的相关信息 print_callees([restriction, ...]) 输出指定的函数调用过的函数的相关信息 sort_stats 可接受参数列表 参数 意义 ncalls 被调用次数 cumulative 函数运行的总时间 file 文件名 module 模块名 pcalls 简单的调用统计 line 行号 name 函数名 nfl Name、file、line stdname 标准函数名 time 函数内部运行时间，不计调用子函数的时间 建议 82：使用 memory_profiler 和 objgraph 剖析内存使用建议 83：努力降低算法复杂度常见数据结构基本操作的时间复杂度 数据结构 操作 平均时间复杂度 最差时间复杂度 list 复制 O(n) O(n) | 追加、取元素的值，给某个元素赋值 | O(_1_) | O(_1_) | 插入、删除某个元素，迭代操作 | O(_n_) | O(_n_) | 切片操作 | O(_k_) | O(_k_) set | x in s | O(1) | O(n) | 并 s or t | O(len(s)+len(t)) | | 交 s&amp;t | O(min(len(s), len(t))) | O(len(s) * len(t)) | 差 s-t | O(len(s)) |dict | 获取修改元素的值，删除 | O(1) | O(n) | 迭代操作 | O(n) | O(n)collections.deque | 入列、出列、（包括左边出入列） | O(1) | O(n) | 扩大队列 | O(k) | O(k) | 删除元素 | O(n) | O(n) 建议 84：掌握循环优化的基本技巧 减少循环内部的计算 将显式循环改为隐式循环 在循环中尽量引用局部变量 关注内层嵌套循环 建议 85：使用生成器提高效率生成器的优点有如下几条： 生成器提供了一种更为便利的产生迭代器的方式，用户一般不需要自己实现 __iter__ 和 next 方法，它默认返回一个迭代器 代码更为简洁、优雅 充分利用了延迟评估的特性，仅在需要的时候才产生对应的元素，而不是一次生成所有的元素，从而节省了内存空间，提高效率 使得协程更为容易实现。（Python3.5 中引入了 async 和 wait 关键字） 建议 86：使用不同的数据结构优化性能建议 87：充分利用 set 的优势建议 88：使用 multiprocessing 克服 GIL 的缺陷Multiprocessing 模块在使用上需要注意以下几个要点： 进程之间的通信优先考虑 Pipe 和 Queue，而不是 Lock、Event、Condition、Semaphore 等同步原语 尽量避免资源共享。如果不可避免，可以通过 multiprocessing.Value 和 multiprocessing.Array 或者 multiprocessing.sharedctype 来实现内存共享。也可以通过服务器进程管理器 Manager() 来实现数据和状态的共享。 注意平台之间的差异。 尽量避免使用 terminate() 方式终止进程，并且确保 pool.map 中传入的参数是可以序列化的 建议 89：使用线程池提高效率建议 90：使用 C&#x2F;C++ 模块扩展提高性能建议 91：使用 Cython 编写扩展模块","categories":[{"name":"Language","slug":"language","permalink":"https://mirokaku.github.io/categories/language/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://mirokaku.github.io/tags/python/"}]},{"title":"ArchLinux 安装笔记","slug":"ArchLinux-install-notes","date":"2016-07-17T16:01:18.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"ArchLinux-install-notes/","permalink":"https://mirokaku.github.io/ArchLinux-install-notes/","excerpt":"前提说明建议优先选择官方文档为参考，内容随时更新且非常详细。这里记录是包含一些自己遇到的坑。且只针对自己安装需求的情况。","text":"前提说明建议优先选择官方文档为参考，内容随时更新且非常详细。这里记录是包含一些自己遇到的坑。且只针对自己安装需求的情况。 环境机器: DELLBOOT: UEFISSD: 256G内存: 8GCPU: i7-6500U安装需求：本机安装单系统ArchLinux: Release 2016.06.01 LiveUSB参考 USB flash installation media (简体中文)推荐使用里面的手动方法，这样制作的LiveUSB可以使用剩余空间来存储其他东西。 安装准备镜像中不包含软件包，安装的软件是通过服务器上的源下载，所以安装的时候必须要有网络连接。 联网有线： 用ip addr 查看网卡接口型号，比如 enp2s0 启用网卡DHCP功能，systemctl enable dhcpcd@enp2s0.service无线： wifi-menu 选择自己的 wifi 并输入密码连接网络 最后 ping 一下，确认网络无误 更新系统时间timedatectl set-ntp true 准备磁盘 lsblk 查看自己的硬盘所在，比如我的就是 &#x2F;dev&#x2F;sda 使用parted 分区注意：我是要全盘安装的，所以重新建立分区表了。a. parted /dev/sdab. (parted) mktable gpt 重建 GPT 分区表c. (parted) mkpart ESP fat32 1M 513M 分配 ESP 分区，前1M是分区表，ESP大小为512Md. (parted) set 1 boot on 设置为ESP分区e. (parted) mkpart primary linux-swap 513M 8705M 分配swap分区，这里使用了与我内存同样大小的8Gf. (parted) mkpart primary ext4 8705M 100% 分配root分区，使用剩余所有空间 格式化分区a. mkfs.vfat –F32 /dev/sda1 ESP分区需要格式化成fat32，否则无法启动b. mkswap /dev/sda2 &amp; swapon /dev/sda2 格式化交换分区，并设置c. mkfs.ext4 –b 4096 /dev/sda3 格式化root分区，并4K对齐 挂载分区a. mount –t ext4 –o discard,noatime /dev/sda3 /mntb. mkdir –p /mnt/boot/EFIc. mount /dev/sda1 /mnt/boot/EFI 安装 配置安装源默认镜像是美国的，在中国速度慢，所以全改中国了..sed -i &#39;/Score/&#123;/China/!&#123;n;s/^/#/&#125;&#125;&#39; /etc/pacman.d/mirrorlist 安装基本系统安装之前先确认是否连网pacstrap /mnt base base-devel vim 生成 fstabgenfstab –U –p /mnt &gt;&gt; /mnt/etc/fstab chrootarch-chroot /mnt /bin/bash Localevim /etc/locale.gen取消下面这些注释en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8 生成locale信息locale-genecho LANG=en_US.UTF-8 &gt; /etc/locale.conf 时间选择时区（Shanghai）tzselect 将 /etc/localtime 软连接到 /usr/share/zoneinfo/Zone/SubZoneln –s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 设置时间标准为 UTC 并调整时间偏移hwclock –systohc –utc 创建初始 ramdisk 环境mkinitcpio –p linux 设置 root 密码passwd 安装 grub先df命令确认一下有木有挂载ESP分区应该是这样的... File system Mounted On &#x2F;dev&#x2F;sda3 &#x2F; &#x2F;dev&#x2F;sda1 &#x2F;boot&#x2F;EFI ... ... pacman –S grub efibootmgrgrub-install –target=x86_64-efi –efi-directory=/boot/EFI –bootloader-id=arch_grub –recheckgrub-mkconfig –o /boot/grub/grub.cfg**注意:**有些BIOS需要自己设置EFI文件位置才能找到efi文件。比如我的DELL 配置网络echo myhostname &gt; /etc/hostname并在 &#x2F;etc&#x2F;hosts 添加同样主机名 123#&lt;ip-address&gt; &lt;hostname.domain.org&gt; &lt;hostname&gt;127.0.0.1 localhost.localdomain localhost myhostname::1 localhost.localdomain localhost myhostname 有线网络Interface 是您的网络接口名，见连网systemctl enable dhcpcd@interface.service 无线网络pacman –S iw wpa_supplicant dialog 卸载分区并重启系统exitumount -R /mntreboot 折腾新大陆重启之后就阔以以root进入到archlinux系统了，首先我们要进行联网。 添加用户useradd –m –g users –G wheel –s /bin/bash usernamepasswd username sudopacman –S sudovim /etc/sudoers找到 root ALL&#x3D;(ALL) ALL照着这个，在下面添加一个 username ALL&#x3D;(ALL) ALL 安装 yaourtvim /etc/pacman.conf加入下面的内容: 1234[archlinuxcn]# The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://mirrors.163.com/archlinux-cn/$arch 更新并安装yaourt 123pacman –Syupacman –S yaourtpacman –S archlinuxcn-keyring 安装 SSH、GIT、wgetpacman –S git openssh wget 安装 zsh 123pacman –S zshchsh /bin/zshsh –c “$(curl –fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 安装 screenfetchpacman –S screenfetch NTFS 读写pacman –S ntfs-3g 安装解压缩软件pacman –S file-roller unrar unzip p7zip Shadowsocks-qt5pacman –S shadowsocks-qt5 ProxyChainspacman –S proxychains RP-PPPOE拨号的，按需安装pacman –S rp-pppoenm-connection-editor 安装 xorg 桌面管理器pacman –S xorg-xinit xorg-server xorg-twm xterm 安装 gnome 桌面环境按需，个人安装的gnome，觉得新版3.20挺好看的pacman –S gnomepacman –S gnome-tweak-tool VPN 扩展 123pacman –S networkmanager-pptpyaourt networkmanager-l2tpsystemctl restart NetworkManager 启动服务显示管理器gnome默认是用的GDMsystemctl enable gdm.service 网络管理systemctl enable NetworkManager.service 更新pacman –Syu 安装 chromiumpacman –S chromium 安装输入法依赖pacman –S fcitx-im fcitx-configtool fcitx-gtk3 fcitx-gtk2 fcitx-qt4 fcitx-qt5 自行选择安装的拼音，我选择的sunpacman –S sunpinyin 配置.xprofile文件vim ~/.xprofile 添加如下内容 12345678export LC_CTYPE=zh_CN.UTF-8export XIM=fcitxexport XIM_PROGRAM=fcitxexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;eval `dbus-launch --sh-syntax --exit-with-session`exec fcitx &amp; 注意，即使这样，你会发现还是调用不出输入法…等下重启之后告诉你如何解决~ 安装网易云音乐pacman –S netease-cloud-music 重启reboot 来到新的世界重启你会发现有了界面~ 配置输入法前面说即使安装完那些东西也调不出来，是有个地方需要配置一下左下角可以有个后台程序栏。右键输入法，选择配置。发现输入法里面并没有拼音，我们添加进安装的 sunpinyin 就好了。注意:切换输入法与 gnome 显示的不一致。默认切换输入法是 ctrl+space 中文化安装中文字体，推荐思源黑体，安装方法见 Github 上的安装过程。安装等宽字体，推荐 Source Code Pro打开 Gnome Tweak Tool，切换到字体栏，将窗口、界面、文档的字体改为 Source Han Sans Normal将等宽字体设置为 Source Code Pro VMWare我这里环境：VMWare: VMware-Workstation-Full-12.1.1-3770994.x86_64.bundleLinux: Linux 4.6.2-1-ARCH 首先从VMWare官网下载个 VMWare二进制包安装部分详见 VMware_(简体中文) 安装依赖mkdir /etc/init.d 添加VMWare服务配置文件yaourt vmware-systemd-servicessystemctl enable vmware.servicesystemctl start vmware.service 有一个地方我要说明一下。在启动提示有个服务跟新的时候，更新会失败，导致不能启动VMWare注意：下面的方法不一定在你的版本适用，请注意备份。解决方法是： 进入 /usr/lib/vmware/modules/source 解包 vmnet.tar vmmon.tar Replace function &quot;get_user_pages()&quot; with &quot;get_user_pages_remote()&quot; in vmmon-only/linux/hostif.c and vmnet-only/userif.c files. 重新打包回去 具体如下：cd /usr/lib/vmware/modules/source 解包sudo tar –xvf vmnet.tarsudo tar –xvf vmmon.tar 把下面两个文件里面的 get_user_pages 函数替换成 get_user_pages_remotesudo vim vmnet-only/driver.csudo vim vmmon-only/linux/hostif.c 打包sudo tar -uvf vmnet.tar vmnet-onlysudo tar -uvf vmmon.tar vmmon-only 然后删除那解包的文件夹sudo rm -r vmnet-onlysudo rm -r vmmon-only 引用参考 Beginners&#39;guide (简体中文)Installation guide (简体中文)给妹子看的 Arch Linux 桌面日常安装ArchLinux 安装笔记寒假折腾Archlinux的一些经验（新手向）--桌面配置篇ArchLinux使用中常见问题集锦 结束","categories":[{"name":"Linux","slug":"linux","permalink":"https://mirokaku.github.io/categories/linux/"}],"tags":[{"name":"ArchLinux","slug":"archlinux","permalink":"https://mirokaku.github.io/tags/archlinux/"}]},{"title":"XP 兼容系列：C++11 的静态对象","slug":"XP-Compatible-cpp11","date":"2016-01-13T08:25:01.000Z","updated":"2025-03-11T05:38:30.000Z","comments":true,"path":"XP-Compatible-cpp11/","permalink":"https://mirokaku.github.io/XP-Compatible-cpp11/","excerpt":"文章可能有错误的地方，希望各位童鞋能够提出~ 事故缘由…为了使用很爽的C++11 特性，我司最新项目是用的VS2015进行开发的。但是同时又要对XP做兼容（讲真，我个人是不支持对Win7之前的系统做兼容的，我觉得影响发展）。 我们写了个COM组件作为插件，和驱动进行通讯。在我们进行单元测试的时候，一切正常。但是出了测试安装包之后，发现加载插件会崩溃。然后我们挂载了Windbg神器来定位崩溃点。崩溃点是一个读取TLS，这个值为空 (外部静态对象才会有TLS)","text":"文章可能有错误的地方，希望各位童鞋能够提出~ 事故缘由…为了使用很爽的C++11 特性，我司最新项目是用的VS2015进行开发的。但是同时又要对XP做兼容（讲真，我个人是不支持对Win7之前的系统做兼容的，我觉得影响发展）。 我们写了个COM组件作为插件，和驱动进行通讯。在我们进行单元测试的时候，一切正常。但是出了测试安装包之后，发现加载插件会崩溃。然后我们挂载了Windbg神器来定位崩溃点。崩溃点是一个读取TLS，这个值为空 (外部静态对象才会有TLS) 想到单元测试程序也是通过VS2015编译的。我们就比较两个进程有啥不一样。如图: 然后我们看一下 nt!_TEB 结构，发现 Tls Storage 就是 _TEB::ThreadLocalStoragePointer 字段。如图： 于是我们查了一下 ReactOS 0.3.15 看下这个字段到底是啥，找到了这个分配Tls的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NTSTATUSNTAPILdrpAllocateTls(VOID)&#123; PTEB Teb = NtCurrentTeb(); PLIST_ENTRY NextEntry, ListHead; PLDRP_TLS_DATA TlsData; SIZE_T TlsDataSize; PVOID *TlsVector; /* Check if we have any entries */ if (!LdrpNumberOfTlsEntries) return STATUS_SUCCESS; /* Allocate the vector array */ TlsVector = RtlAllocateHeap(RtlGetProcessHeap(), 0, LdrpNumberOfTlsEntries * sizeof(PVOID)); if (!TlsVector) return STATUS_NO_MEMORY; Teb-&gt;ThreadLocalStoragePointer = TlsVector; /* Loop the TLS Array */ ListHead = &amp;LdrpTlsList; NextEntry = ListHead-&gt;Flink; while (NextEntry != ListHead) &#123; /* Get the entry */ TlsData = CONTAINING_RECORD(NextEntry, LDRP_TLS_DATA, TlsLinks); NextEntry = NextEntry-&gt;Flink; /* Allocate this vector */ TlsDataSize = TlsData-&gt;TlsDirectory.EndAddressOfRawData - TlsData-&gt;TlsDirectory.StartAddressOfRawData; TlsVector[TlsData-&gt;TlsDirectory.Characteristics] = RtlAllocateHeap(RtlGetProcessHeap(), 0, TlsDataSize); if (!TlsVector[TlsData-&gt;TlsDirectory.Characteristics]) &#123; /* Out of memory */ return STATUS_NO_MEMORY; &#125; /* Show debug message */ if (ShowSnaps) &#123; DPRINT1(&quot;LDR: TlsVector %x Index %d = %x copied from %x to %x\\n&quot;, TlsVector, TlsData-&gt;TlsDirectory.Characteristics, &amp;TlsVector[TlsData-&gt;TlsDirectory.Characteristics], TlsData-&gt;TlsDirectory.StartAddressOfRawData, TlsVector[TlsData-&gt;TlsDirectory.Characteristics]); &#125; /* Copy the data */ RtlCopyMemory(TlsVector[TlsData-&gt;TlsDirectory.Characteristics], (PVOID)TlsData-&gt;TlsDirectory.StartAddressOfRawData, TlsDataSize); &#125; /* Done */ return STATUS_SUCCESS;&#125; 但是这个函数并不能得到太多有用信息。我们又看了下谁调用了它，得到了 LdrpInitializeTls 这个函数，从这个函数里面，我们就知道，实际上 _TEB::ThreadLocalStoragePointer 这个字段就是 初始化好的PE文件里面的 Tls 表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NTSTATUSNTAPILdrpInitializeTls(VOID)&#123; PLIST_ENTRY NextEntry, ListHead; PLDR_DATA_TABLE_ENTRY LdrEntry; PIMAGE_TLS_DIRECTORY TlsDirectory; PLDRP_TLS_DATA TlsData; ULONG Size; /* Initialize the TLS List */ InitializeListHead(&amp;LdrpTlsList); /* Loop all the modules */ ListHead = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InLoadOrderModuleList; NextEntry = ListHead-&gt;Flink; while (ListHead != NextEntry) &#123; /* Get the entry */ LdrEntry = CONTAINING_RECORD(NextEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); NextEntry = NextEntry-&gt;Flink; /* Get the TLS directory */ TlsDirectory = RtlImageDirectoryEntryToData(LdrEntry-&gt;DllBase, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &amp;Size); /* Check if we have a directory */ if (!TlsDirectory) continue; /* Check if the image has TLS */ if (!LdrpImageHasTls) LdrpImageHasTls = TRUE; /* Show debug message */ if (ShowSnaps) &#123; DPRINT1(&quot;LDR: Tls Found in %wZ at %p\\n&quot;, &amp;LdrEntry-&gt;BaseDllName, TlsDirectory); &#125; /* Allocate an entry */ TlsData = RtlAllocateHeap(RtlGetProcessHeap(), 0, sizeof(LDRP_TLS_DATA)); if (!TlsData) return STATUS_NO_MEMORY; /* Lock the DLL and mark it for TLS Usage */ LdrEntry-&gt;LoadCount = -1; LdrEntry-&gt;TlsIndex = -1; /* Save the cached TLS data */ TlsData-&gt;TlsDirectory = *TlsDirectory; InsertTailList(&amp;LdrpTlsList, &amp;TlsData-&gt;TlsLinks); /* Update the index */ *(PLONG)TlsData-&gt;TlsDirectory.AddressOfIndex = LdrpNumberOfTlsEntries; TlsData-&gt;TlsDirectory.Characteristics = LdrpNumberOfTlsEntries++; &#125; /* Done setting up TLS, allocate entries */ return LdrpAllocateTls();&#125; 到了这步，我们以为可以很容易的解决问题，既然需要Tls目录，那我们给它一个不就行了？所以我们给测试代码添加了一个Tls目录.. 1234567#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)#pragma data_seg(&quot;.CRT$XLB&quot;) PIMAGE_TLS_CALLBACK TlsCallBackArray[] = &#123; TlsCallBackFunction &#125;;#pragma data_seg() 不过我们还是太天真了..我们的Tls的回调啥也没做，所以在程序执行的时候，执行到并没有初始化的对象直接崩溃了..（对，VS2015生成的Tls表（回调）就是用来初始化静态对象的。） 后来...我们在 MSDN 发现一个相关的说明 Starting in C++11, a static local variable initialization is guaranteed to be thread-safe.This feature is sometimes called magic statics.However, in a multithreaded application all subsequent assignments must be synchronized.The thread-safe statics feature can be disabled by using the &#x2F;Zc:threadSafeInit- flag to avoid taking a dependency on the CRT. 大致意思是，由于在C++11开始可以保证静态本地变量初始化时是线程安全的，即“神奇的静态对象”但是这个特性是默认需要CRT支持的，所以需要增加一条编译选项来关闭它。 1/Zc:threadSafeInit- 这样在XP上运行就不会出现问题了。 好了，结束~以此记录，来避免自己再遇到同样的坑 (●ˇ∀ˇ●) 引用链接：Storage class (C++)","categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"}],"tags":[{"name":"Windows XP","slug":"windows-xp","permalink":"https://mirokaku.github.io/tags/windows-xp/"}]}],"categories":[{"name":"Windows","slug":"windows","permalink":"https://mirokaku.github.io/categories/windows/"},{"name":"other","slug":"other","permalink":"https://mirokaku.github.io/categories/other/"},{"name":"Language","slug":"language","permalink":"https://mirokaku.github.io/categories/language/"},{"name":"Linux","slug":"linux","permalink":"https://mirokaku.github.io/categories/linux/"}],"tags":[{"name":"Kernel","slug":"kernel","permalink":"https://mirokaku.github.io/tags/kernel/"},{"name":"INF","slug":"inf","permalink":"https://mirokaku.github.io/tags/inf/"},{"name":"Hack","slug":"hack","permalink":"https://mirokaku.github.io/tags/hack/"},{"name":"Windbg","slug":"windbg","permalink":"https://mirokaku.github.io/tags/windbg/"},{"name":"Debug","slug":"debug","permalink":"https://mirokaku.github.io/tags/debug/"},{"name":"Objective-C","slug":"objective-c","permalink":"https://mirokaku.github.io/tags/objective-c/"},{"name":"Python","slug":"python","permalink":"https://mirokaku.github.io/tags/python/"},{"name":"ArchLinux","slug":"archlinux","permalink":"https://mirokaku.github.io/tags/archlinux/"},{"name":"Windows XP","slug":"windows-xp","permalink":"https://mirokaku.github.io/tags/windows-xp/"}]}